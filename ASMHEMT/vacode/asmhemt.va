/* ASM HEMT Model Version 101.4.0 released by Sourabh Khandelwal on 04-30-2023
Copyright 2023 Sourabh Khandelwal
Copyright 2022 Sourabh Khandelwal
Copyright 2021 Sourabh Khandelwal
Copyright 2020 Sourabh Khandelwal and Indian Institute of Technology Kanpur
Copyright 2019 Sourabh Khandelwal and Indian Institute of Technology Kanpur
Copyright 2018 Sourabh Khandelwal and Indian Institute of Technology Kanpur
Copyright 2014 Sourabh Khandelwal and Indian Institute of Technology Kanpur
Copyright 2013 Norwegian University of Science and Technology Trondheim and Indian Institute of Technology Kanpur
Copyright 2012 Norwegian University of Science and Technology Trondheim

Current Authors: Sourabh Khandelwal, Fredo Chavez, and Nikhil Reddy
Previous Developers: Aamir Hasan, Sudip Ghosh, Avirup Dasgupta, Yogesh Chauhan
Contact: sourabh.khandelwal@mq.edu.au, sourabhkhandelwal@gmail.com
*/
/*
ASM HEMT model is supported by the members of Silicon Integration Initiative's Compact Model Coalition. A link to the most recent version of this
standard can be found at: http://www.si2.org/cmc
*/
`include "disciplines.vams"
`include "constants.vams"

////////// Numerical and Physical Constants //////////
`define DOS 3.240e17           //Density of states, Reference M. Shur Plenum Press 1987, GaAs Device and Circuits
`define ep_psi 0.3             //Smoothing Constant
`define Oneby3 0.33333333333333333
`define Twoby3 0.66666666666666667
`define EXPL_THRESHOLD 80.0
`define MAX_EXPL 5.540622384e+34
`define MIN_EXPL 1.804851387e-35
`define KboQ 8.617087e-5       // J/deg
////////// Macros for the model/instance parameters //////////
/*
 MPRxx    model    parameter real
 MPIxx    model    parameter integer
 IPRxx    instance parameter real
 IPIxx    instance parameter integer
    ||
    cc    closed lower bound, closed upper bound
    oo    open   lower bound, open   upper bound
    co    closed lower bound, open   upper bound
    oc    open   lower bound, closed upper bound
    cz    closed lower bound=0, open upper bound=inf
    oz    open   lower bound=0, open upper bound=inf
    nb    no bounds
    ex    no bounds with exclude
    sw    switch(integer only, values  0=false  and  1=true)
    ty    switch(integer only, values -1=p-type and +1=n-type)

 IPM   instance parameter mFactor(multiplicity, implicit for LRM2.2)
 OPP   operating point parameter, includes units and description for printing
 */

`define OPP(nam,uni,des)               (*units=uni,                   desc=des*)           real    nam;
`define OPM(nam,uni,des)               (* desc=des, units=uni, multiplicity="multiply" *)  real    nam;
`define OPD(nam,uni,des)               (* desc=des, units=uni, multiplicity="divide"   *)  real    nam;
`define MPRnb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def;
`define MPRex(nam,def,uni,exc,    des) (*units=uni,                   desc=des*) parameter real    nam=def exclude exc;
`define MPRcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr];
`define MPRoo(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr);
`define MPRco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr);
`define MPRoc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr];
`define MPRcz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def from[  0:inf);
`define MPRoz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def from(  0:inf);
`define MPInb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def;
`define MPIex(nam,def,uni,exc,    des) (*units=uni,                   desc=des*) parameter integer nam=def exclude exc;
`define MPIcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr];
`define MPIoo(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from(lwr:upr);
`define MPIco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr);
`define MPIoc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from(lwr:upr];
`define MPIcz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[  0:inf);
`define MPIoz(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from(  0:inf);
`define MPIsw(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[  0:  1];
`define MPIty(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[ -1:  1] exclude 0;
`define IPRnb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def ;
`define IPRex(nam,def,uni,exc,    des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def exclude exc;
`define IPRcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr];
`define IPRoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr);
`define IPRco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr);
`define IPRoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr];
`define IPRcz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[  0:inf);
`define IPRoz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(  0:inf);
`define IPInb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def;
`define IPIex(nam,def,uni,exc,    des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def exclude exc;
`define IPIcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[lwr:upr];
`define IPIoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(lwr:upr);
`define IPIco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[lwr:upr);
`define IPIoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(lwr:upr];
`define IPIcz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[  0:inf);
`define IPIoz(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from(  0:inf);

/*
Not all Verilog-A compilers are able to properly collapse internal nodes. To ensure minimal node
count, comment out the following lines:
*/

`define __FP1MOD__
`define __FP2MOD__
`define __FP3MOD__
`define __FP4MOD__
`define __FP1SMOD__
`define __FP2SMOD__
`define __FP3SMOD__
`define __FP4SMOD__
////////// Function for VG0 Calculation //////////
`define VG0(l,w,Voff_dibl_temp,imin,Vgs,Vtv,Vg0) \
t0     = l/(2.0*w*`P_Q*`DOS*Vtv*Vtv); \
vgmin  = Voff_dibl_temp + Vtv*ln(t0*imin); \
vggmin = 0.5*((Vgs-vgmin) + sqrt((Vgs-vgmin)*(Vgs-vgmin) + 1.0e-4)) + vgmin; \
Vg0    = vggmin - Voff_dibl_temp;

////////// Function for PSIS Calculation //////////
`define PSIS(Cg,Vg0,GAMMA0Ival,GAMMA1Ival,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis) \
beta   = Cg/(`P_Q*`DOS*Vtv); \
ALPHAN = `M_E/beta; \
ALPHAD = 1.0/beta; \
Cch    = Cg/`P_Q; \
vgop   = 0.5*Vg0 + 0.5*sqrt(Vg0*Vg0 + 4.0*`ep_psi*`ep_psi); \
vgopacc = vgop ; \
vgon   = vgop*ALPHAN/(sqrt(vgop*vgop + ALPHAN*ALPHAN)); \
vgod   = vgop*ALPHAD/(sqrt(vgop*vgop + ALPHAD*ALPHAD)); \
Hx     = (vgop + Vtv*(1.0-ln(beta*vgon)) - (GAMMA0Ival/3.0)*pow(Cch*vgop,`Twoby3))/(vgop*(1.0+(Vtv/vgod)) + ((2.0*GAMMA0Ival)/3.0)*pow(Cch*vgop,`Twoby3)); \
t0     = (Vg0/(2.0*Vtv)); \
if (t0 < 200.0) begin  \
    t1  = lexp(t0/4.0); \
    t2  = lexp(-3.0*t0/4.0); \
    nsx = (2.0*Vtv*(Cch)*((3.0*t0/4.0)+ln(t1 + t2)))/((1.0/Hx) + (Cch/`DOS)*lexp((-1.0*Vg0)/(2.0*Vtv))); \
end else begin  \
    nsx = (2.0*Vtv*(Cch)*((1.0*t0/1.0)))/((1.0/Hx) + (Cch/`DOS)*lexp((-1.0*Vg0)/(2.0*Vtv))); \
end \
ef1 = Vg0 - nsx/Cch; \
if (abs(ef1-Vg0) > 1.0e-19) begin \
    vgef1    = Vg0 - ef1; \
    vgef1    = 0.5*vgef1 + 0.5*sqrt(vgef1*vgef1 + 4.0*1.0e-9*1.0e-9); \
    t0       = pow(Cch,`Twoby3); \
    t1       = pow(vgef1,`Twoby3); \
    t2       = pow(vgef1,-`Oneby3); \
    vgef23g0 = GAMMA0Ival*t0*t1; \
    vgef23g1 = GAMMA1Ival*t0*t1; \
    tg0      = (ef1/Vtv) - (vgef23g0/Vtv); \
    tg1      = (ef1/Vtv) - (vgef23g1/Vtv); \
    t4       = Cch*vgef1 - `DOS*Vtv*ln_exp_plus_1(tg0) - `DOS*Vtv*ln_exp_plus_1(tg1); \
    vgefm13g0 = GAMMA0Ival*t0*t2; \
    vgefm13g1 = GAMMA1Ival*t0*t2; \
    t5ng0     = lexp(tg0)*`DOS*(1.0 + `Twoby3*vgefm13g0); \
    t5dg0     = 1.0 + lexp(tg0); \
    t5ng1     = lexp(tg1)*`DOS*(1.0 + `Twoby3*vgefm13g1); \
    t5dg1     = 1.0 + lexp(tg1); \
    t5        = -1.0*Cch - (t5ng0/t5dg0) - (t5ng1/t5dg1); \
    ef2       = ef1 - (t4/t5); \
    vgef2     = Vg0 - ef2; \
    vgef2     = 0.5*vgef2 + 0.5*sqrt(vgef2*vgef2 + 4.0*1.0e-9*1.0e-9); \
    t3        = pow(vgef2,-`Oneby3); \
    vgef223g0 = GAMMA0Ival*t0*pow(vgef2,`Twoby3); \
    vgef223g1 = GAMMA1Ival*t0*pow(vgef2,`Twoby3); \
    tg02      = (ef2/Vtv) - (vgef223g0/Vtv); \
    tg12      = (ef2/Vtv) - (vgef223g1/Vtv); \
    t42       = Cch*vgef2 - `DOS*Vtv*ln_exp_plus_1(tg02) - `DOS*Vtv*ln_exp_plus_1(tg12); \
    vgefm213g0 = GAMMA0Ival*t0*t3; \
    vgefm213g1 = GAMMA1Ival*t0*t3; \
    t5ng02     = lexp(tg02)*`DOS*(1.0 + `Twoby3*vgefm213g0); \
    t5dg02     = 1.0 + lexp(tg02); \
    t5ng12     = lexp(tg12)*`DOS*(1.0 + `Twoby3*vgefm213g1); \
    t5dg12     = 1.0 + lexp(tg12); \
    t52        = -1.0*Cch - (t5ng02/t5dg02) - (t5ng12/t5dg12); \
    ef3        = ef2 - (t42/t52); \
    psis       = ef3 ; \
end else begin \
    psis       = ef1 ; \
end

////////// Function for PSID Calculation //////////
`define PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,U0val,ute,VSATval,at,Cg,psis,Vg0,ua,ub,l,Vds,GAMMA0Ival, GAMMA1Ival,   mulf_tdev,Vdeff,psid) \
mulf_tdev = U0val*pow((Tdev/Tnom),ute); \
vsat_tdev = VSATval*pow((Tdev/Tnom),at); \
t0        = (Cg/epsilon)*abs(Vg0 - psis); \
mu_eff    = mulf_tdev/(1.0 + ua*(t0) + ub*t0*t0); \
t0        = 2.0*vsat_tdev/mu_eff; \
t1        = 0.5*Vg0 + 0.5*sqrt(Vg0*Vg0 + 4.0*`ep_psi*`ep_psi); \
Vdsat     = t0*l*t1/(t0*l + t1 ); \
t0        = pow(Vds/Vdsat, delta); \
t1        = pow(1.0 + t0,-1.0/delta); \
Vdeff     = Vds * t1; \
Vgdeff    = Vg0 - Vdeff; \
vgod      = Vgdeff; \
vgodp     = 0.5*vgod + 0.5*sqrt(vgod*vgod + 4.0*`ep_psi*`ep_psi); \
vgop      = vgodp ; \
dvgon     = vgop*ALPHAN/(sqrt(vgop*vgop + ALPHAN*ALPHAN)); \
dvgod     = vgop*ALPHAD/(sqrt(vgop*vgop + ALPHAD*ALPHAD)); \
Hx        = (vgop + Vtv*(1.0-ln(beta*dvgon)) - (GAMMA0Ival/3.0)*pow(Cch*vgop,`Twoby3))/(vgop*(1.0+(Vtv/dvgod)) + ((2.0*GAMMA0Ival)/3.0)*pow(Cch*vgop,`Twoby3)); \
t0        = (vgod/(2.0*Vtv)); \
if (t0 < 200.0) begin  \
    t1 = lexp(t0/4.0); \
    t2 = lexp(-3.0*t0/4.0); \
    ndx = (2.0*Vtv*(Cch)*((3.0*t0/4.0)+ln(t1 + t2)))/((1.0/Hx) + (Cch/`DOS)*lexp((-1.0*vgod)/(2.0*Vtv))); \
end else begin  \
    ndx = (2.0*Vtv*(Cch)*((1.0*t0/1.0)))/((1.0/Hx) + (Cch/`DOS)*lexp((-1.0*vgod)/(2.0*Vtv))); \
end \
ef1 = vgod - ndx/Cch; \
if (abs(ef1-vgod)>1.0e-19) begin \
    vgef1 = vgod - ef1; \
    vgef1 = 0.5*vgef1 + 0.5*sqrt(vgef1*vgef1 + 4.0*1.0e-9*1.0e-9); \
    t0    = pow(Cch,`Twoby3) ; \
    t1    = pow(vgef1,`Twoby3) ; \
    t2    = pow(vgef1,-`Oneby3) ; \
    vgef23g0 = GAMMA0Ival*t0*t1; \
    vgef23g1 = GAMMA1Ival*t0*t1; \
    tg0      = (ef1/Vtv) - (vgef23g0/Vtv); \
    tg1      = (ef1/Vtv) - (vgef23g1/Vtv); \
    t4       = Cch*vgef1 - `DOS*Vtv*ln_exp_plus_1(tg0) - `DOS*Vtv*ln_exp_plus_1(tg1); \
    vgefm13g0 = GAMMA0Ival*t0*t2; \
    vgefm13g1 = GAMMA1Ival*t0*t2; \
    t5ng0     = lexp(tg0)*`DOS*(1.0 + `Twoby3*vgefm13g0); \
    t5dg0     = 1.0 + lexp(tg0); \
    t5ng1     = lexp(tg1)*`DOS*(1.0 + `Twoby3*vgefm13g1); \
    t5dg1     = 1.0 + lexp(tg1); \
    t5        = -1.0*Cch - (t5ng0/t5dg0) - (t5ng1/t5dg1); \
    ef2       = ef1 - (t4/t5); \
    vgef2     = vgod - ef2; \
    vgef2     = 0.5*vgef2 + 0.5*sqrt(vgef2*vgef2 + 4.0*1.0e-9*1.0e-9); \
    vgef223g0 = GAMMA0Ival*t0*pow(vgef2,`Twoby3); \
    vgef223g1 = GAMMA1Ival*t0*pow(vgef2,`Twoby3); \
    tg02      = (ef2/Vtv) - (vgef223g0/Vtv); \
    tg12      = (ef2/Vtv) - (vgef223g1/Vtv); \
    t42       = Cch*vgef2 - `DOS*Vtv*ln_exp_plus_1(tg02) - `DOS*Vtv*ln_exp_plus_1(tg12); \
    vgefm213g0 = GAMMA0Ival*t0*pow(vgef2,-`Oneby3); \
    vgefm213g1 = GAMMA1Ival*t0*pow(vgef2,-`Oneby3); \
    t5ng02     = lexp(tg02)*`DOS*(1.0 + `Twoby3*vgefm213g0); \
    t5dg02     = 1.0 + lexp(tg02); \
    t5ng12     = lexp(tg12)*`DOS*(1.0 + `Twoby3*vgefm213g1); \
    t5dg12     = 1.0 + lexp(tg12); \
    t52        = -1.0*Cch - (t5ng02/t5dg02) - (t5ng12/t5dg12); \
    ef3        = ef2 - (t42/t52); \
    psid       = ef3 + Vdeff ; \
end else begin \
    psid       = ef1 + Vdeff ; \
end

////////// Function for IDS Calculation //////////
`define IDS(Vg0,psim,psisd,Cg,l,Vdsx,w,nf,Vtv,mulf_tdev,Vdeff,   Ids) \
ids0   = (Vg0 - psim + Vtv)*(psisd); \
t0     = (Cg/epsilon)*abs(Vg0 - psim); \
mu_eff = mulf_tdev/(1.0 + ua*(t0) + ub*t0*t0) ; \
Geff   = (mu_eff*Cg*w*nf)/(l); \
Geff_clm = Geff*(1.0 + lambda*(Vdsx-Vdeff)); \
vf       = sqrt(1.0 + thesat*thesat*psisd*psisd) ; \
G_vf     = Geff_clm/vf; \
Ids      = G_vf*(ids0);

////////// Function for QGI Calculation //////////
`define QGI(Vg0,psis,psid,psim,Cg,l,QM0Ival,BDOSIval,ADOSIval,TBARval,Vtv,w,nf,   Cg_qme,qgint) \
t0 = Vg0 + Vtv ; \
t1 = psid - psis; \
t2 = Vg0 + Vtv - psim; \
t3 = (Cg*w*nf*l)*(Vg0 - psim + 0.5*t1*t1/(6.0*t2)); \
T0 = 1.0e+26 * (t3/QM0Ival); \
T1 = 1.0 + pow(T0, BDOSIval); \
XDCinv = ADOSIval / T1; \
Cg_qme = epsilon/(TBARval + XDCinv); \
qgint = (Cg_qme*w*nf*l)*(Vg0 - psim + 0.5*t1*t1/(6.0*t2));

////////// Function for QDI Calculation //////////
`define QDI(Vg0,psim,psis,psid,psisd,l,Vtv,w,nf,Cg_qme,   qdint) \
t0 = Vg0 + Vtv - psim ; \
t1 = (psis + 2.0*psid)/3.0 ; \
t2 = (1.0/12.0)*(psisd*psisd)/t0 ; \
t3 = (1.0/120.0)*(psisd*psisd*psisd)/(t0*t0) ; \
qdint = -(Cg_qme*w*l*nf*0.5)*(Vg0 - t1 + t2 + t3) ;

`define ISL(Vdsx,Vth,w,nf,asl,nsl,bvdsl,  isl) \
t0 = lexp((Vdsx-bvdsl)/(nsl*Vth)); \
t1 = lexp((-bvdsl)/(nsl*Vth)); \
isl = w*nf*asl*(t0 - t1);

//////// Function for parameter calculation ////////////
`define PCAL(vinp,vmax,pin,ptune, pout) \
t0 = vinp*vmax; \
t1 = sqrt(vinp*vinp + vmax*vmax); \
pout = abs(ptune*pin)*(t0/t1);

//////// Function for saturation effect modeling in non-linear access region resistance ////////
`define isat(Ids,isatacc,ar, idseff) \
tmp=1.0+(ar); \
kv=sqrt(tmp)*(Ids); \
kvv=kv/(isatacc); \
kvv2=kvv*2.0; \
tmp=tmp+kvv*kvv; \
tmp=sqrt(tmp-kvv2)+sqrt(tmp+kvv2); \
idseff=kv*2.0/tmp;
/*
Model Schematic:


                                                               O (g) Gate
                                                               |
                                                           Gate Resistor
                                                               |
                                                               O (gi)           Source (s) connected
                                                               |                        O
                                                        |---------------|               |
                                                        |               |               |
                                                    |-------|       |-------|       |-------|
                                                    |       |       |       |       |       |
                          O--------/\/\/\/\----O----|       |---O---|       |---O---|       |---O------/\/\/\/\----------O
                  Source (s)       S ACC RES  (si)  MAIN HEMT  (di)    FP1    (fp1)    FP2    (fp2)   D ACC RES         (d) Drain
                                                        |
                                                        |
                                                        O (b) Substrate



*/

module asmhemt(d,g,s,b,dt);
    inout d,g,s,b,dt;
    electrical d,g,s,b;
    electrical trap1, trap2;
    electrical di, si, gi, gin;
    electrical n1,nt,n2,ntg;
    thermal dt;


////////// Node Conditioning For Field-plates //////////
    `ifdef __FP1MOD__
        electrical fp1;
    `endif

    `ifdef __FP1MOD__
        `define IntrinsicDrain_fp1 fp1
    `else
        `define IntrinsicDrain_fp1 di
    `endif
///////////////////////////////
    `ifdef __FP2MOD__
        electrical fp2;
    `endif

    `ifdef __FP2MOD__
        `define IntrinsicDrain_fp2 fp2
    `else
        `define IntrinsicDrain_fp2 `IntrinsicDrain_fp1
    `endif
//////////////////////////////
    `ifdef __FP3MOD__
        electrical fp3;
    `endif

    `ifdef __FP3MOD__
        `define IntrinsicDrain_fp3 fp3
    `else
        `define IntrinsicDrain_fp3 `IntrinsicDrain_fp2
    `endif
//////////////////////////////
    `ifdef __FP4MOD__
        electrical fp4;
    `endif

    `ifdef __FP4MOD__
        `define IntrinsicDrain_fp4 fp4
    `else
        `define IntrinsicDrain_fp4 `IntrinsicDrain_fp3
    `endif
/////////////////////////////////////////////////////
    `ifdef __FP1SMOD__
        electrical fp1s;
    `endif

    `ifdef __FP1SMOD__
        `define IntrinsicSource_fp1s fp1s
    `else
        `define IntrinsicSource_fp1s si
    `endif
/////////////////////////////////////////////////////
    `ifdef __FP2SMOD__
        electrical fp2s;
    `endif

    `ifdef __FP2SMOD__
        `define IntrinsicSource_fp2s fp2s
    `else
        `define IntrinsicSource_fp2s `IntrinsicSource_fp1s
    `endif
//////////////////////////////////////////////////////
    `ifdef __FP3SMOD__
        electrical fp3s;
    `endif

    `ifdef __FP3SMOD__
        `define IntrinsicSource_fp3s fp3s
    `else
        `define IntrinsicSource_fp3s `IntrinsicSource_fp2s
    `endif
    //////////////////////////////////////////////////////
    `ifdef __FP4SMOD__
        electrical fp4s;
    `endif

    `ifdef __FP4SMOD__
        `define IntrinsicSource_fp4s fp4s
    `else
        `define IntrinsicSource_fp4s `IntrinsicSource_fp3s
    `endif
////////// Clamped Exponential Function //////////
    analog function real lexp;
        input x;
        real x;
        begin
            if (x > `EXPL_THRESHOLD) begin
                lexp = `MAX_EXPL * (1.0+(x)-`EXPL_THRESHOLD);
            end else if (x < -`EXPL_THRESHOLD) begin
                lexp = `MIN_EXPL;
            end else begin
                lexp = exp(x);
            end
        end
    endfunction

////////// Hyperbolic Smoothing Functions (max) //////////
    analog function real hypmax;
        input x , xmin, c;
        real x , xmin, c;
        begin
            hypmax  = xmin + x - 0.5 * (xmin + x - sqrt((x-xmin)*(x-xmin)+c));
        end
    endfunction

////////// Smoothing Function To Fix A Minimum Value //////////
    analog function real smoothminx;
        input x, x0, dx;
        real x, x0, dx;
        begin
            smoothminx = 0.5*(x + x0 + sqrt((x - x0)*(x - x0) + 0.25*dx*dx));
        end
    endfunction

////////// Smoothing Function To Fix A Maximum Value //////////
    analog function real smoothmax;
        input x, x0, dx;
        real x, x0, dx;
        begin
            smoothmax = 0.5*(x + x0 - sqrt((x - x0)*(x - x0) + dx*dx)-(x0 - sqrt(x0*x0 + dx*dx)));
        end
    endfunction
/////////// ln(lexp(arg) + 1) function /////////////////////////
    analog function real ln_exp_plus_1;
        input x; real x;
        begin
            if (x >= 37) begin
                ln_exp_plus_1 = x;
            end else if (x <= -37) begin
                ln_exp_plus_1 = 0;
            end else begin
                ln_exp_plus_1 = ln(exp(x) + 1);
            end
        end
    endfunction
////////// Branches Self-heating //////////
    branch (dt) rth;
    branch (dt) ith;

////////// List Of Model Parameters //////////
    `MPRco( tnom           ,27.0           ,"deg C"       ,-`P_CELSIUS0,inf         ," Nominal Temperature in degree Celsius" )
    `MPRco( tbar           ,2.5e-8         ,"m"           ,0.1e-9      ,inf         ," Barrier layer thickness" )
    `MPRco( tepi           ,1.64e-6        ,"m"           ,0.1e-9      ,inf         ," GaN epi layer thickness" )
    `IPRco( l              ,0.25e-6        ,"m"           ,20e-9       ,inf         ," Channel Length" )
    `IPRco( w              ,200.0e-6       ,"m"           ,20e-9       ,inf         ," Channel Width of a finger" )
    `IPIco( nf             ,1              ,""            ,1.0         ,inf         ," Number of fingers" )
    `MPRoo( epsilon        ,10.66e-11      ,"F/m"         ,0.0         ,inf         ," Dielectric Permittivity of AlGaN layer" )
    `MPRcc( voff           ,-2.0           ,"V"           ,-100.0      ,5           ," Cut-off voltage" )
    `MPRcc( asub           ,0.0            ,"V/V"         ,-100.0      ,100         ," Parameter for substrate coupling effects" )
    `MPRco( u0             ,170.0e-3       ,"m^2/(V * s)" ,0.0         ,inf         ," Low field mobility" )
    `MPRco( ua             ,0.0e-9         ,"V^-1"        ,0.0         ,inf         ," Mobility Degradation coefficient first order" )
    `MPRco( ub             ,0.0e-18        ,"V^-2"        ,0.0         ,inf         ," Mobility Degradation coefficient second order" )
    `MPRco( vsat           ,1.9e5          ,"m/s"         ,1.0e3       ,inf         ," Saturation Velocity" )
    `MPRco( delta          ,2.0            ,""            ,2.0         ,inf         ," Exponent for Vdeff" )
    `MPRoo( at             ,0.0            ,""            ,-inf        ,inf         ," Temperature Dependence for saturation velocity" )
    `MPRcc( ute            ,-0.5           ,""            ,-10.0       ,0           ," Temperature dependence of mobility" )
    `MPRco( lambda         ,0.0            ,"V^-1"        ,0.0         ,inf         ," Channel Length Modulation Coefficient" )
    `MPRco( eta0           ,1.0e-9         ,""            ,0.0         ,inf         ," DIBL Parameter" )
    `MPRoo( vdscale        ,5.0            ,"V"           ,0.0         ,inf         ," DIBL Scaling VDS" )
    `MPRoo( kt1            ,0.0e-3         ,""            ,-inf        ,inf         ," Temperature Dependence for Voff" )
    `MPRco( thesat         ,1.0            ,"V^-2"        ,1.0         ,inf         ," Velocity Saturation Parameter" )
    `MPRco( nfactor        ,0.5            ,""            ,0.0         ,inf         ," Sub-voff Slope parameters" )
    `MPRco( cdscd          ,1.0e-3         ,""            ,0.0         ,inf         ," Sub-voff Slope Change due to Drain Voltage" )
    `MPRcc( gamma0i        ,2.12e-12       ,""            ,0.0         ,1.0         ," Schrodinger-Poisson solution parameter" )
    `MPRcc( gamma1i        ,3.73e-12       ,""            ,0.0         ,1.0         ," Schrodinger-Poisson solution parameter" )
    `MPRoo( imin           ,1.0e-15        ,"A"           ,0.0         ,inf         ," Minimum Drain Current" )
////////// Self Heating Model Parameters //////////
    `MPIsw( shmod          ,1              ,""                                      ," Switch to turn on and off self-heating model" )
    `MPRco( rth0           ,5.0            ,"K/w"         ,0.0         ,inf         ," Thermal Resistance" )
    `MPRco( cth0           ,1.0e-9         ,"s*w/K"       ,0.0         ,inf         ," Thermal Capacitance" )
////////// Access Region Resistance Model Parameters //////////
    `MPIsw( rdsmod         ,0              ,""                                      ," Switch for external source and drain resistances" )
    `MPRoo( vsataccs       ,50.0e3         ,"cm/s"        ,0.0         ,inf         ," Saturation Velocity for access region: Source Side" )
    `MPRco( ns0accs        ,5.0e17         ,"C/m^-2"      ,1.0e5       ,inf         ," 2-DEG Charge Density in per square meter in Source access region" )
    `MPRco( ns0accd        ,5.0e17         ,"C/m^-2"      ,1.0e5       ,inf         ," 2-DEG Charge Density in per square meter in Drain access region" )
    `MPRco( k0accs         ,0.0            ,""            ,0.0         ,inf         ," Vg dependence parameter of source side access region 2-DEG charge density" )
    `MPRco( k0accd         ,0.0            ,""            ,0.0         ,inf         ," Vg dependence parameter of drain side access region 2-DEG charge density" )
    `MPRoo( u0accs         ,155e-3         ,"m^2/(V * s)" ,0.0         ,inf         ," Access region mobility source-side" )
    `MPRoo( u0accd         ,155e-3         ,"m^2/(V * s)" ,0.0         ,inf         ," Access region mobility drain-side" )
    `MPRoo( mexpaccs       ,2.0            ,""            ,0.0         ,inf         ," Exponent for access region resistance model" )
    `MPRoo( mexpaccd       ,2.0            ,""            ,0.0         ,inf         ," Exponent for access region resistance model" )
    `MPRoo( ard            ,1.0            ,""            ,0.0         ,inf         ," Saturation tuning for access region resistance model" )
    `MPRoo( ars            ,1.0            ,""            ,0.0         ,inf         ," Saturation tuning for access region resistance model" )
    `MPRco( lsg            ,1.0e-6         ,"m"           ,0.0         ,inf         ," Length of Source-Gate Access Region" )
    `MPRco( ldg            ,1.0e-6         ,"m"           ,0.0         ,inf         ," Length of Drain-Gate Access Region or Length of drain side access region" )
    `MPRco( rsc            ,1.0e-4         ,"ohm*m"       ,0.0         ,inf         ," Source Contact Resistance" )
    `MPRco( rdc            ,1.0e-4         ,"ohm*m"       ,0.0         ,inf         ," Drain Contact Resistance" )
    `MPRco( kns0           ,0.0            ,""            ,0.0         ,inf         ," Temperature Dependence for 2-DEG charge density at access region" )
    `MPRoo( ats            ,0.0            ,""            ,-inf        ,inf         ," Temperature Dependence for saturation velocity at access region" )
    `MPRoo( utes           ,0.0            ,""            ,-inf        ,inf         ," Temperature dependence of mobility at access region: Source Side" )
    `MPRoo( uted           ,0.0            ,""            ,-inf        ,inf         ," Temperature dependence of mobility at access region: Drain Side" )
    `MPRco( krsc           ,0.0            ,""            ,0.0         ,inf         ," Temperature dependence of Source Contact Resistance" )
    `MPRco( krdc           ,0.0            ,""            ,0.0         ,inf         ," Temperature dependence of Drain Contact Resistance" )
    `MPIcc( gatemod        ,0              ,""            ,0           ,2           ," Model Switch to turn on and off the gate current formulations" )
////////// Gate current Model Parameters (MOD) //////////
    `MPRoo( njgs           ,2.5            ,""            ,0.0         ,50.0        ," Gate-source junction diode current ideality factor" )
    `MPRoo( njgd           ,2.5            ,""            ,0.0         ,50.0        ," Gate-drain junction diode current ideality factor" )
    `MPRoo( rnjgs          ,80.0           ,""            ,0.0         ,inf         ," Gate-source junction diode rev. current slope factor" )
    `MPRoo( rnjgd          ,80.0           ,""            ,0.0         ,inf         ," Gate-drain junction diode rev. current slope factor" )
    `MPRco( igsdio         ,1.0e-12        ,"A/m^2"       ,0.0         ,inf         ," Gate-source junction diode saturation current" )
    `MPRco( igddio         ,1.0e-12        ,"A/m^2"       ,0.0         ,inf         ," Gate-drain junction diode saturation current" )
    `MPRco( rigsdio        ,1.0e-15        ,"A/m^2"       ,0.0         ,inf         ," Gate-source junction diode rev. current frenkel-poole multiplier" )
    `MPRco( rigddio        ,1.0e-15        ,"A/m^2"       ,0.0         ,inf         ," Gate-drain junction diode  rev. current frenkel-poole multiplier" )
    `MPRoo( vbis           ,1e-4           ,"V"           ,0.0         ,inf         ," Gate-source junction diode built-in voltage" )
    `MPRoo( vbid           ,1e-4           ,"V"           ,0.0         ,inf         ," Gate-drain junction diode built-in voltage" )
    `MPRco( ebreaks        ,0.0            ,"V^0.5"       ,0.0         ,inf         ," Fitting parameter for large rev bias gate current" )
    `MPRco( ebreakd        ,0.0            ,"V^0.5"       ,0.0         ,inf         ," Fitting parameter for large rev bias gate current" )
    `MPRoo( ktgs           ,0.0            ,""            ,-inf        ,inf         ," Temperature co-efficient of gate-source junction diode current" )
    `MPRoo( ktgd           ,0.0            ,""            ,-inf        ,inf         ," Temperature coefficient of gate-drain junction diode current" )
    `MPRoo( rktgs          ,0.0            ,""            ,-inf        ,inf         ," Temperature co-efficient of reverse gate-source junction diode current" )
    `MPRoo( rktgd          ,0.0            ,""            ,-inf        ,inf         ," Temperature coefficient of reverse gate-drain junction diode current" )
    `MPRoo( ktvbis         ,0.0            ,"V"           ,-inf         ,inf        ," Temperature coefficient for built-in voltage source side" )
    `MPRoo( ktvbid         ,0.0            ,"V"           ,-inf         ,inf        ," Temperature coefficient for built-in voltage drain side" )
    `MPRoo( ktnjgs         ,0.0            ,"V"           ,-inf         ,inf        ," Temperature coefficient forward slope source-side" )
    `MPRoo( ktnjgd         ,0.0            ,"V"           ,-inf         ,inf        ," Temperature coefficient forward slope drain-side" )
    `MPRoo( ktrnjgs        ,0.0            ,"V"           ,-inf         ,inf        ," Temperature coefficient reverse slope source-side" )
    `MPRoo( ktrnjgd        ,0.0            ,"V"           ,-inf         ,inf        ," Temperature coefficient reverse slope drain-side" )
    `MPIcc( trapmod        ,0              ,""            ,0            ,4          ," Model Switch to turn on and off the dynamic trapping effects" )
////////// Trap Model For RF trapmod=4 //////////
    `MPRoo( remi           ,1.0            ,""            ,0.0         ,inf         ," Drain lag emission resistance" )
    `MPRoo( cglag          ,10.0e-6        ,""            ,0.0         ,inf         ," Gate lag trapping capacitance" )
    `MPRoo( remig          ,1.0            ,""            ,0.0         ,inf         ," Gate lag trapping resistance" )
    `MPRoo( arcap          ,0.0            ,""            ,-inf        ,inf         ," Drain lag trap potential tuning parameter" )
    `MPRoo( brcap          ,0.5            ,""            ,0.0         ,inf         ," Drain lag trap potential tuning parameter" )
    `MPRoo( arcapg         ,0.0            ,""            ,-inf        ,inf         ," Gate lag trap potential tuning parameter" )
    `MPRoo( brcapg         ,0.5            ,""            ,0.0         ,inf         ," Gate lag trap potential tuning parameter" )
    `MPRoo( vdlmax         ,20.0           ,""            ,0.0         ,inf         ," Drain lag parameter for limiting parameter change" )
    `MPRoo( vglmax         ,5.0            ,""            ,0.0         ,inf         ," Gate lag parameter for limiting parameter change" )
    `MPRoo( dlvoff         ,0e-4           ,""            ,-inf        ,inf         ," Voff tuning due to drain lag" )
    `MPRoo( glvoff         ,0e-4           ,""            ,-inf        ,inf         ," Voff tuning due to gate lag" )
    `MPRoo( glu0           ,0e-4           ,""            ,-inf        ,inf         ," U0 tuning due to drain lag" )
    `MPRoo( glvsat         ,0e-4           ,""            ,-inf        ,inf         ," VSAT tuning due to gate lag" )
    `MPRoo( dlns0s         ,0e-4           ,""            ,-inf        ,inf         ," Source-side 2-deg tune due to drain lag" )
    `MPRoo( dlns0d         ,0e-4           ,""            ,-inf        ,inf         ," Drain-side 2-deg tune due to gate-lag" )
////////// Trap model parameters for trapmod=4 and trapmod=1
    `MPRoo( cdlag          ,1.0e-6         ,""            ,0.0         ,inf         ," Trap Network capacitance, shared parameter trapmod=1 and 4" )
    `MPRoo( rdlag          ,1.0e6          ,""            ,0.0         ,inf         ," Trap Network resistance, shared parameter trapmod=1 and 4" )
/////////  Trap model parameters for trapmod=1
    `MPRoo( idio           ,1.0e0          ,"A"           ,0.0         ,inf         ," Saturation Current parameter for trap model" )
    `MPRoo( atrapvoff      ,0.1            ,""            ,-inf        ,inf         ," Voff change due to trapping effects" )
    `MPRoo( btrapvoff      ,0.3            ,""            ,-inf        ,inf         ," Voff change with input power due to trapping effects" )
    `MPRoo( atrapeta0      ,0              ,""            ,-inf        ,inf         ," DIBL change due to trapping effects" )
    `MPRoo( btrapeta0      ,0.05           ,""            ,-inf        ,inf         ," DIBL change with input power due to trapping effects" )
    `MPRoo( atraprs        ,0.1            ,""            ,-inf        ,inf         ," Rs change due to trapping effects" )
    `MPRoo( btraprs        ,0.6            ,""            ,-inf        ,inf         ," Rs change with input power due to trapping effects" )
    `MPRoo( atraprd        ,0.5            ,""            ,-inf        ,inf         ," Rd change due to trapping effects" )
    `MPRoo( btraprd        ,0.6            ,""            ,-inf        ,inf         ," Rd change with input power due to trapping effects" )
////////// Trap Model Parameters for Pulse IV trapmod=2 //////////
    `MPRoo( rtrap1         ,1.0            ,"ohm"         ,0.0         ,inf         ," Trap Network1 Resistance" )
    `MPRoo( rtrap2         ,1.0            ,"ohm"         ,0.0         ,inf         ," Trap Network2 Resistance" )
    `MPRco( ctrap1         ,10.0e-6        ,"F"           ,0.0         ,inf         ," Trap Network1 Capacitance" )
    `MPRco( ctrap2         ,1.0e-6         ,"F"           ,0.0         ,inf         ," Trap Network2 Capacitance" )
    `MPRoo( a1             ,0.1            ,""            ,-inf        ,inf         ," Multiplication factor [1st network]" )
    `MPRoo( vofftr         ,1.0e-9         ,""            ,-inf        ,inf         ," Trap contribution to voff [2nd network]" )
    `MPRoo( cdscdtr        ,1.0e-15        ,""            ,-inf        ,inf         ," Trap contribution to cdscd [2nd network]" )
    `MPRoo( eta0tr         ,1.0e-15        ,""            ,-inf        ,inf         ," Trap contribution to DIBL [2nd network]" )
    `MPRoo( rontr1         ,1.0e-12        ,""            ,-inf        ,inf         ," Trap contribution to RON [1st network]" )
    `MPRoo( rontr2         ,1.0e-13        ,""            ,-inf        ,inf         ," Trap contribution to RON [2nd network]" )
    `MPRoo( rontr3         ,1.0e-13        ,""            ,-inf        ,inf         ," Trap contribution to RON" )
////////// Trap Model Parameters Dynamic On Resistance For Power Devices trapmod=3 //////////
    `MPRoo( rtrap3         ,1.0            ,"ohm"         ,0.0         ,inf         ," Trap Network Resistance" )
    `MPRco( ctrap3         ,1.0e-4         ,"F"           ,0.0         ,inf         ," Trap Network Capacitance" )
    `MPRoo( vatrap         ,10.0           ,""            ,0.0         ,inf         ," Division factor for V[trap1]" )
    `MPRoo( wd             ,0.016          ,""            ,-inf        ,inf         ," Weak dependence of vdlr1 on Vdg" )
    `MPRoo( vdlr1          ,2.0            ,""            ,-inf        ,inf         ," Slope for region one" )
    `MPRoo( vdlr2          ,20.0           ,""            ,-inf        ,inf         ," Slope for region two" )
    `MPRoo( talpha         ,1.0            ,""            ,-inf        ,inf         ," Temperature dependence Coefficient" )
    `MPRco( vtb            ,250.0          ,"V"           ,0.0         ,inf         ," Break Point for Vdg effect on Von" )
    `MPRco( deltax         ,0.01           ,""            ,0.0         ,inf         ," Smoothing parameter" )
////////// Field Plate Region Parameters //////////
    `MPIcc( fastfpmod      ,0              ,""            ,0           ,1           ," Fast field-plate model formulations [0:Conventional FP model; 1: Fast model calculations]" )
    `MPIcc( fp1mod         ,0              ,""            ,0           ,2           ," Drain-side Field Plate Model Selector [0:No FP; 1:Gate FP; 2:Source FP;]" )
    `MPIcc( fp1smod        ,0              ,""            ,0           ,2           ," Source-side Field Plate Model Selector [0:No FP; 1:Gate FP; 2:Source FP;]" )
    `MPIcc( fp2mod         ,0              ,""            ,0           ,2           ," Drain-side Field Plate Model Selector [0:No FP; 1:Gate FP; 2:Source FP;]" )
    `MPIcc( fp2smod        ,0              ,""            ,0           ,2           ," Source-side Field Plate Model Selector [0:No FP; 1:Gate FP; 2:Source FP;]" )
    `MPIcc( fp3mod         ,0              ,""            ,0           ,2           ," Drain-side Field Plate Model Selector [0:No FP; 1:Gate FP; 2:Source FP;]" )
    `MPIcc( fp3smod        ,0              ,""            ,0           ,2           ," Source-side Field Plate Model Selector [0:No FP; 1:Gate FP; 2:Source FP;]" )
    `MPIcc( fp4mod         ,0              ,""            ,0           ,2           ," Drain-side Field Plate Model Selector [0:No FP; 1:Gate FP; 2:Source FP;]" )
    `MPIcc( fp4smod        ,0              ,""            ,0           ,2           ," Source-side Field Plate Model Selector [0:No FP; 1:Gate FP; 2:Source FP;]" )
    `MPRoo( iminfp1        ,1.0e-15        ,"A"           ,0.0         ,inf         ," Minimum Drain Current FP1 region" )
    `MPRcc( vofffp1        ,-25.0          ,"V"           ,-500.0      ,5           ," voff for FP1" )
    `IPRco( dfp1           ,50.0e-9        ,"m"           ,0.1e-9      ,inf         ," Distance of FP1 from 2-DEG Charge" )
    `IPRoo( lfp1           ,1.0e-6         ,"m"           ,0.0         ,inf         ," Length of FP1" )
    `MPRoo( ktfp1          ,50.0e-3        ,""            ,-inf        ,inf         ," Temperature Dependence for vofffp1" )
    `MPRco( u0fp1          ,100e-3         ,"m^2/(V * s)" ,0.0         ,inf         ," FP1 region mobility" )
    `MPRco( vsatfp1        ,100e+3         ,"m/s"         ,0.0         ,inf         ," Saturation Velocity of FP1 region" )
    `MPRco( nfactorfp1     ,0.5            ,""            ,0.0         ,inf         ," Sub-voff Slope parameters for FP1" )
    `MPRco( cdscdfp1       ,0.0            ,""            ,0.0         ,inf         ," Sub-voff Slope Change due to Drain Voltage for FP1" )
    `MPRco( eta0fp1        ,1.0e-9         ,""            ,0.0         ,inf         ," DIBL Parameter for FP1" )
    `MPRoo( vdscalefp1     ,10.0           ,"V"           ,0.0         ,inf         ," DIBL Scaling VDS for FP1" )
    `MPRcc( gamma0fp1      ,2.12e-12       ,""            ,0.0         ,1.0         ," Schrodinger-Poisson solution parameter for FP1" )
    `MPRcc( gamma1fp1      ,3.73e-12       ,""            ,0.0         ,1.0         ," Schrodinger-Poisson solution parameter for FP1" )
    `MPRoo( iminfp2        ,1.0e-15        ,"A"           ,0.0         ,inf         ," Minimum Drain Current FP2 region" )
    `MPRcc( vofffp2        ,-80.0          ,"V"           ,-100.0      ,5           ," voff for FP2" )
    `IPRco( dfp2           ,100.0e-9       ,"m"           ,0.1e-9      ,inf         ," Distance of FP2 from 2-DEG Charge" )
    `IPRoo( lfp2           ,1.0e-6         ,"m"           ,0.0         ,inf         ," Length of FP2" )
    `MPRoo( ktfp2          ,50.0e-3        ,""            ,-inf        ,inf         ," Temperature Dependence for vofffp2" )
    `MPRco( u0fp2          ,100e-3         ,"m^2/(V * s)" ,0.0         ,inf         ," Carrier mobility of FP2 region" )
    `MPRco( vsatfp2        ,100e+3         ,"m/s"         ,0.0         ,inf         ," Saturation velocity of FP2 region" )
    `MPRco( nfactorfp2     ,0.5            ,""            ,0.0         ,inf         ," Sub-voff Slope parameters for FP2" )
    `MPRco( cdscdfp2       ,0.0            ,""            ,0.0         ,inf         ," Sub-voff Slope Change due to Drain Voltage for FP2" )
    `MPRco( eta0fp2        ,1.0e-9         ,""            ,0.0         ,inf         ," DIBL Parameter for FP2" )
    `MPRoo( vdscalefp2     ,10.0           ,"V"           ,0.0         ,inf         ," DIBL Scaling VDS for FP2" )
    `MPRcc( gamma0fp2      ,2.12e-12       ,""            ,0.0         ,1.0         ," Schrodinger-Poisson solution parameter for FP2" )
    `MPRcc( gamma1fp2      ,3.73e-12       ,""            ,0.0         ,1.0         ," Schrodinger-Poisson solution parameter for FP2" )
    `MPRoo( iminfp3        ,1.0e-15        ,"A"           ,0.0         ,inf         ," Minimum Drain Current FP3 region" )
    `MPRcc( vofffp3        ,-75.0          ,"V"           ,-500.0      ,5           ," voff for FP3" )
    `IPRco( dfp3           ,150.0e-9       ,"m"           ,0.1e-9      ,inf         ," Distance of FP3 from 2-DEG Charge" )
    `IPRoo( lfp3           ,1.0e-6         ,"m"           ,0.0         ,inf         ," Length of FP3" )
    `MPRoo( ktfp3          ,50.0e-3        ,""            ,-inf        ,inf         ," Temperature Dependence for vofffp3" )
    `MPRco( u0fp3          ,100e-3         ,"m^2/(V * s)" ,0.0         ,inf         ," FP3 region mobility" )
    `MPRco( vsatfp3        ,100e+3         ,"m/s"         ,0.0         ,inf         ," Saturation Velocity of FP3 region" )
    `MPRco( nfactorfp3     ,0.5            ,""            ,0.0         ,inf         ," Sub-voff Slope parameters for FP3" )
    `MPRco( cdscdfp3       ,0.0            ,""            ,0.0         ,inf         ," Sub-voff Slope Change due to Drain Voltage for FP3" )
    `MPRco( eta0fp3        ,1.0e-9         ,""            ,0.0         ,inf         ," DIBL Parameter for FP3" )
    `MPRoo( vdscalefp3     ,10.0           ,"V"           ,0.0         ,inf         ," DIBL Scaling VDS for FP3" )
    `MPRcc( gamma0fp3      ,2.12e-12       ,""            ,0.0         ,1.0         ," Schrodinger-Poisson solution parameter for FP3" )
    `MPRcc( gamma1fp3      ,3.73e-12       ,""            ,0.0         ,1.0         ," Schrodinger-Poisson solution parameter for FP3" )
    `MPRoo( iminfp4        ,1.0e-15        ,"A"           ,0.0         ,inf         ," Minimum Drain Current FP4 region" )
    `MPRcc( vofffp4        ,-100.0         ,"V"           ,-500.0      ,5           ," voff for FP4" )
    `IPRco( dfp4           ,200.0e-9       ,"m"           ,0.1e-9      ,inf         ," Distance of FP4 from 2-DEG Charge" )
    `IPRoo( lfp4           ,1.0e-6         ,"m"           ,0.0         ,inf         ," Length of FP4" )
    `MPRoo( ktfp4          ,50.0e-3        ,""            ,-inf        ,inf         ," Temperature Dependence for vofffp4" )
    `MPRco( u0fp4          ,100e-3         ,"m^2/(V * s)" ,0.0         ,inf         ," FP4 region mobility" )
    `MPRco( vsatfp4        ,100e+3         ,"m/s"         ,0.0         ,inf         ," Saturation Velocity of FP4 region" )
    `MPRco( nfactorfp4     ,0.5            ,""            ,0.0         ,inf         ," Sub-voff Slope parameters for FP4" )
    `MPRco( cdscdfp4       ,0.0            ,""            ,0.0         ,inf         ," Sub-voff Slope Change due to Drain Voltage for FP4" )
    `MPRco( eta0fp4        ,1.0e-9         ,""            ,0.0         ,inf         ," DIBL Parameter for FP4" )
    `MPRoo( vdscalefp4     ,10.0           ,"V"           ,0.0         ,inf         ," DIBL Scaling VDS for FP4" )
    `MPRcc( gamma0fp4      ,2.12e-12       ,""            ,0.0         ,1.0         ," Schrodinger-Poisson solution parameter for FP4" )
    `MPRcc( gamma1fp4      ,3.73e-12       ,""            ,0.0         ,1.0         ," Schrodinger-Poisson solution parameter for FP4" )
////////// Capacitance Parameters //////////
    `MPRco( cgso           ,10.0e-15       ,"F"           ,0.0         ,inf         ," Gate-source overlap capacitance" )
    `MPRco( cgdo           ,10.0e-15       ,"F"           ,0.0         ,inf         ," Gate-drain overlap capacitance" )
    `MPRco( cdso           ,10.0e-15       ,"F"           ,0.0         ,inf         ," Cds capacitance parameter" )
    `MPRco( cgdl           ,0.0e-15        ,"F"           ,0.0         ,inf         ," Vds bias dependence of parasitic gate drain overlap capacitance" )
    `MPRoo( vdsatcv        ,100.0          ,"V"           ,0.0         ,inf         ," Saturation voltage on drain side in CV Model" )
    `MPRco( cbdo           ,0.0e-15        ,"F"           ,0.0         ,inf         ," Substrate capacitance parameter" )
    `MPRco( cbso           ,0.0e-15        ,"F"           ,0.0         ,inf         ," Substrate capacitance parameter" )
    `MPRco( cbgo           ,0.0e-15        ,"F"           ,0.0         ,inf         ," Substrate capacitance parameter" )
    `MPRco( cfg            ,0.0e-18        ,"F"           ,0.0         ,inf         ," Fringing capacitance parameter" )
    `MPRco( cfd            ,0.0e-18        ,"F"           ,0.0         ,inf         ," Fringing capacitance parameter" )
    `MPRco( cfgd           ,0.0e-13        ,"F"           ,0.0         ,inf         ," Fringing capacitance parameter" )
    `MPRco( cfgdsm         ,1.0e-24        ,"F"           ,0.0         ,inf         ," Capacitance smoothing parameter" )
    `MPRco( cfgd0          ,0.0e-12        ,"F"           ,0.0         ,inf         ," Fringing capacitance parameter" )
    `MPRco( cj0            ,0.0e-15        ,"F"           ,0.0         ,inf         ," Zero bias depletion capacitance" )
    `MPRoo( vbi            ,0.9            ,"V"           ,0.0         ,inf         ," Built in potential" )
    `MPRco( ktvbi          ,0.0            ,""            ,0.0         ,inf         ," Temperature dependence of built in potential" )
    `MPRco( ktcfg          ,0.0e-3         ,""            ,0.0         ,inf         ," Temperature dependence of Fringing capacitance" )
    `MPRco( ktcfgd         ,0.0e-3         ,""            ,0.0         ,inf         ," Temperature dependence of Fringing capacitance" )
    `MPRoo( mz             ,0.5            ,""            ,0.0         ,1.0         ," Grading factor of depletion capacitance" )
    `MPRoo( aj             ,100.0e-3       ,""            ,0.0         ,inf         ," Limiting factor of depletion capacitance in forward bias region" )
    `MPRco( dj             ,1.0            ,""            ,0.0         ,2.0         ," Fitting parameter " )
////////// Quantum Mechanical Effects //////////
    `MPRco( adosi          ,0.0            ,""            ,0           ,inf         ," Quantum mechanical effect pre-factor cum switch in inversion" )
    `MPRco( bdosi          ,1.0            ,""            ,0           ,inf         ," Charge centroid parameter - slope of CV curve under QME in inversion" )
    `MPRoo( qm0i           ,1.0e-3         ,""            ,0           ,inf         ," Charge centroid parameter - starting point for QME in inversion" )
    `MPRco( adosfp1        ,0.0            ,""            ,0           ,inf         ," Quantum mechanical effect pre-factor cum switch in inversion" )
    `MPRco( bdosfp1        ,1.0            ,""            ,0           ,inf         ," Charge centroid parameter - slope of CV curve under QME in inversion" )
    `MPRoo( qm0fp1         ,1.0e-3         ,""            ,0           ,inf         ," Charge centroid parameter - starting point for QME in inversion" )
    `MPRco( adosfp2        ,0.0            ,""            ,0           ,inf         ," Quantum mechanical effect pre-factor cum switch in inversion" )
    `MPRco( bdosfp2        ,1.0            ,""            ,0           ,inf         ," Charge centroid parameter - slope of CV curve under QME in inversion" )
    `MPRoo( qm0fp2         ,1.0e-3         ,""            ,0           ,inf         ," Charge centroid parameter - starting point for QME in inversion" )
    `MPRco( adosfp3        ,0.0            ,""            ,0           ,inf         ," Quantum mechanical effect pre-factor cum switch in inversion" )
    `MPRco( bdosfp3        ,1.0            ,""            ,0           ,inf         ," Charge centroid parameter - slope of CV curve under QME in inversion" )
    `MPRoo( qm0fp3         ,1.0e-3         ,""            ,0           ,inf         ," Charge centroid parameter - starting point for QME in inversion" )
    `MPRco( adosfp4        ,0.0            ,""            ,0           ,inf         ," Quantum mechanical effect pre-factor cum switch in inversion" )
    `MPRco( bdosfp4        ,1.0            ,""            ,0           ,inf         ," Charge centroid parameter - slope of CV curve under QME in inversion" )
    `MPRoo( qm0fp4         ,1.0e-3         ,""            ,0           ,inf         ," Charge centroid parameter - starting point for QME in inversion" )
////////// Cross Coupling Capacitance Parameters //////////
    `MPRco( cfp1scale      ,0.0            ,""            ,0           ,inf         ," Coupling of charge under FP1" )
    `MPRco( cfp2scale      ,0.0            ,""            ,0           ,inf         ," Coupling of charge under FP2" )
    `MPRco( cfp3scale      ,0.0            ,""            ,0           ,inf         ," Coupling of charge under FP3" )
    `MPRco( cfp4scale      ,0.0            ,""            ,0           ,inf         ," Coupling of charge under FP4" )
    `MPRco( csubscalei     ,0.0            ,""            ,0           ,inf         ," Sub Capacitance scaling parameter" )
    `MPRco( csubscale1     ,0.0            ,""            ,0           ,inf         ," Sub Capacitance scaling parameter" )
    `MPRco( csubscale2     ,0.0            ,""            ,0           ,inf         ," Sub Capacitance scaling parameter" )
    `MPRco( csubscale3     ,0.0            ,""            ,0           ,inf         ," Sub Capacitance scaling parameter" )
    `MPRco( csubscale4     ,0.0            ,""            ,0           ,inf         ," Sub Capacitance scaling parameter" )
////////// Gate Resistance Parameters //////////
    `MPIcc( rgatemod       ,0              ,""            ,0           ,2           ," Model Switch to turn on and off the gate resistance" )
    `MPRco( xgw            ,0.0            ,"m"           ,0           ,inf         ," Distance from gate contact centre to dev edge" )
    `IPIcc( ngcon          ,1              ,""            ,1           ,2           ," Number of gate contacts" )
    `MPRco( rshg           ,1.0e-3         ,"ohm/square"  ,1e-3        ,inf         ," Gate sheet resistance" )
////////// Noise Model Parameters //////////
    `MPIsw( fnmod          ,0              ,""                                      ," Switch to turn Flicker Noise Model  ON [fnmod=1] or OFF [fnmod=0]" )
    `MPIsw( tnmod          ,0              ,""                                      ," Switch to turn Thermal Noise Model  ON [tnmod=1] or OFF [tnmod=0]" )
    `MPRoo( noia           ,15.0e-12       ,""            ,-inf        ,inf         ," Flicker Noise parameter" )
    `MPRco( noib           ,0.0            ,""            ,0           ,inf         ," Flicker Noise parameter" )
    `MPRco( noic           ,0.0            ,""            ,0           ,inf         ," Flicker Noise parameter" )
    `MPRoo( ef             ,1              ,""            ,0           ,inf         ," Exponent of frequency---Determines slope in log plot" )
    `MPRoo( tnsc           ,1.0e27         ,""            ,0           ,inf         ," Thermal noise scaling parameter" )
////////// gdsmin For Convergence //////////
    `MPRoo( gdsmin         ,1.0e-12        ,"S"           ,0           ,inf          ,"Shunt conductance across channel and all field plates" )
/////////  Breakdown model parameters
    `MPRco( bvdsl          ,200.0          ,"V"           ,10          ,inf          ,"Drain-source breakdown due to punch-through" )
    `MPRco( asl            ,0.0            ,"A/m"         ,0.0         ,inf          ,"Breakdown model multiplier parameter" )
    `MPRco( nsl            ,10.0           ,""            ,1.0         ,inf          ,"Exponent in the breakdown model" )
    `MPRoo( kasl           ,0.0            ,""            ,-inf        ,inf          ,"Temperature Dependence for asl parameters in breakdown" )
    `MPRoo( knsl           ,0.0            ,""            ,-inf        ,inf          ,"Temperature Dependence for nsl parameters in breakdown" )
    `MPRoo( kbvdsl         ,0.0            ,""            ,-inf        ,inf          ,"Temperature Dependence for bvdsl parameters in breakdown" )
//////////// Device variability handles ////////////
    `IPRoo( dtemp          ,0.0            ,""            ,-inf        ,inf          ,"Temperature variability parameter" )
////////// Operating Point Variables //////////
    `OPM(idisi, "A", "Intrinsic drain-to-source current")
    `OPP(vdisi, "V", "Intrinsic drain-to-source voltage")
    `OPP(vgisi, "V", "Intrinsic drain-to-source voltage")
    `OPM(gmi,   "A/V", "Intrinsic trans-conductance")
    `OPM(gdsi,  "A/V", "Intrinsic output conductance")
    `OPM(gmbi,  "A/V", "Intrinsic bulk trans-conductance")
    `OPM(igs,   "A", "Gate to source current")
    `OPM(igd,   "A", "Gate to source current")
    `OPM(qgi,   "C", "Intrinsic gate charge")
    `OPM(qdi,   "C", "Intrinsic drain charge")
    `OPM(qsi,   "C", "Intrinsic source charge")
    `OPM(qbi,   "C", "Intrinsic bulk charge")
    `OPM(cggi,  "F", "Intrinsic gate capacitance")
    `OPM(cgsi,  "F", "Intrinsic gate-to-source capacitance")
    `OPM(cgdi,  "F", "Intrinsic gate-to-drain capacitance")
    `OPM(cgbi,  "F", "Intrinsic gate-to-bulk capacitance")
    `OPM(cddi,  "F", "Intrinsic drain capacitance")
    `OPM(cdgi,  "F", "Intrinsic drain-to-gate capacitance")
    `OPM(cdsi,  "F", "Intrinsic drain-to-source capacitance")
    `OPM(cdbi,  "F", "Intrinsic drain-to-bulk capacitance")
    `OPM(cssi,  "F", "Intrinsic source capacitance")
    `OPM(csgi,  "F", "Intrinsic source-to-gate capacitance")
    `OPM(csdi,  "F", "Intrinsic source-to-drain capacitance")
    `OPM(csbi,  "F", "Intrinsic source-to-bulk capacitance")
    `OPM(cbbi,  "F", "Intrinsic bulk capacitance")
    `OPM(cbsi,  "F", "Intrinsic bulk-to-source capacitance")
    `OPM(cbdi,  "F", "Intrinsic bulk-to-drain capacitance")
    `OPM(cbgi,  "F", "Intrinsic bulk-to-gate capacitance")
    `OPP(t_total_k, "K", "Device temperature in Kelvin")
    `OPP(t_total_c, "deg C", "Device temperature in Celsius")
    `OPP(t_delta_sh, "K", "Increase in device temperature due to self-heating")
    `OPD(rd,   "Ohm", "Drain resistance")
    `OPD(rs,   "Ohm", "Source resistance")
    `OPM(cgs,  "F", "Total gate-to-source capacitance")
    `OPM(cgd,  "F", "Total gate-to-drain capacitance")
///////////////////////////////////////////////////////////////////

    analog begin
        begin : voltages
            real Tnom, Vth;
            real Vg0, Vds, Vgdeff, Vgs, sigvds, Vds_noswap, Vgs_noswap, Vgd_noswap, Vbs;
            real sigvdsfp1, Vds_noswapfp1, Vgs_noswapfp1, Vgd_noswapfp1;
            real sigvdsfp1s, Vds_noswapfp1s, Vgs_noswapfp1s, Vgd_noswapfp1s;
            real sigvdsfp2, Vds_noswapfp2, Vgs_noswapfp2, Vgd_noswapfp2;
            real sigvdsfp2s, Vds_noswapfp2s, Vgs_noswapfp2s, Vgd_noswapfp2s;
            real sigvdsfp3, Vds_noswapfp3, Vgs_noswapfp3, Vgd_noswapfp3;
            real sigvdsfp3s, Vds_noswapfp3s, Vgs_noswapfp3s, Vgd_noswapfp3s;
            real sigvdsfp4, Vds_noswapfp4, Vgs_noswapfp4, Vgd_noswapfp4;
            real sigvdsfp4s, Vds_noswapfp4s, Vgs_noswapfp4s, Vgd_noswapfp4s;
            real Cg, Cepi, Tdev, Vtv, beta, Vdsat, Vdeff, Voff_dibl, Voff_dibl_temp, vsat_tdev ;
            real t1, t2, vf, G_vf, Ids, mu_eff, Geff, mulf_tdev, Geff_clm;
            real Cch, ef1, vgef1, vgef23g0, vgef23g1, tg0, tg1;
            real t4, vgefm13g0, vgefm13g1, t5ng0,t5dg0, t5ng1, t5dg1, t5, ef2, vgef2, vgef223g0, vgef223g1, tg02, tg12, t42, vgefm213g0, vgefm213g1;
            real t5ng02, t5dg02, t5ng12, t5dg12, t52, ef3, psis, vgod, vgodp, psid, psim, psisd, ids0;
            real t0, t3, qd, qs, Vdsx, gdpr, gspr, Rdrain, Rsource, cdsc;
            real vdg, vdgeff, ct;
            real ALPHAN, ALPHAD, Hx, nsx, vgop, vgon, ndx, dvgon, dvgod ;
            real vgmin, vggmin ;
            real qgint, qsov, qdov, qdsov, qdint, qsint, cgdvar, VdseffCV, cgdl_l;
            real rsbias, rdbias, qsacc, isatacc, rd0, rs0 ;
            real vsataccs_t, ns0_t, rsc_t, rdc_t, u0accs_t, u0accd_t, cr, crm;
            real Rtrap, Rtrap_t, vcap, vgopacc;
            real T0, T1, XDCinv, Cg_qme, t6, t8, Qdep, qfr, qfr2, qfr3;
            real Pf, Kr, FNint1, FNint2, FNint3, FNint4, FNat1Hz;
            real ThSid;
            real Igs, Igd;
            real vdgeff1, voff_trap, ron_trap, cdscd_trap, eta0_trap;
            real voff_cap, rs_cap, rd_cap, eta0_cap;
            real qdp, qsp, qbdov, qbsov, qbgov;
            real Vg0_fp1, Cg_fp1, psis_fp1, psid_fp1, psim_fp1, psisd_fp1, qg_fp1, qd_fp1, Vgs_fp1, Vds_fp1, Vdsx_fp1, qs_fp1, Ids_fp1;
            real Vg0_fp1s, Cg_fp1s, psis_fp1s, psid_fp1s, psim_fp1s, psisd_fp1s, qg_fp1s, qd_fp1s, Vgs_fp1s, Vds_fp1s, Vdsx_fp1s, qs_fp1s, Ids_fp1s;
            real Vg0_fp2, Cg_fp2, psis_fp2, psid_fp2, psim_fp2, psisd_fp2, qg_fp2, qd_fp2, Vgs_fp2, Vds_fp2, Vdsx_fp2, qs_fp2, Ids_fp2;
            real Vg0_fp2s, Cg_fp2s, psis_fp2s, psid_fp2s, psim_fp2s, psisd_fp2s, qg_fp2s, qd_fp2s, Vgs_fp2s, Vds_fp2s, Vdsx_fp2s, qs_fp2s, Ids_fp2s;
            real Vg0_fp3, Cg_fp3, psis_fp3, psid_fp3, psim_fp3, psisd_fp3, qg_fp3, qd_fp3, Vgs_fp3, Vds_fp3, Vdsx_fp3, qs_fp3, Ids_fp3;
            real Vg0_fp3s, Cg_fp3s, psis_fp3s, psid_fp3s, psim_fp3s, psisd_fp3s, qg_fp3s, qd_fp3s, Vgs_fp3s, Vds_fp3s, Vdsx_fp3s, qs_fp3s, Ids_fp3s;
            real Vg0_fp4, Cg_fp4, psis_fp4, psid_fp4, psim_fp4, psisd_fp4, qg_fp4, qd_fp4, Vgs_fp4, Vds_fp4, Vdsx_fp4, qs_fp4, Ids_fp4;
            real Vg0_fp4s, Cg_fp4s, psis_fp4s, psid_fp4s, psim_fp4s, psisd_fp4s, qg_fp4s, qd_fp4s, Vgs_fp4s, Vds_fp4s, Vdsx_fp4s, qs_fp4s, Ids_fp4s;
            real Grgeltd, Grgeltd1, Grgeltd2;
            real mvgs, efield, mvgd, rigsdio_t, rigddio_t, vbis_t, vbid_t, njgs_t, njgd_t, rnjgs_t, rnjgd_t;
            real isl,aslt,tempr,nslt,bvdslt;
            real vaux, Rnon, voffdlag, ns0sdlag, ns0ddlag;
            real vauxg, Rnong, voffglag, u0glag, vsatglag, u0_i, vsat_i;
            real idseff,tmp,kv,kvv,kvv2;
            integer ars_chk, ard_chk;
////////// Variable initialization //////////
            t6 = 0.0; t8 = 0.0; Qdep = 0.0; qfr = 0.0; qfr2 = 0.0; qfr3 = 0.0;
            vcap = 1.0;
            voff_cap = 0.0; rs_cap = 0.0; rd_cap = 0.0; eta0_cap = 0.0; Ids = 0.0;
            voff_trap = 0.0; ron_trap= 0.0; cdscd_trap=0.0; eta0_trap=0.0; Rtrap_t = 0.0 ;
            Vg0_fp1 = 0.0; Cg_fp1 = 0.0; psis_fp1 = 0.0; psid_fp1 = 0.0; psim_fp1 = 0.0; psisd_fp1 = 0.0; qg_fp1 = 0.0; qd_fp1 = 0.0;
            qs_fp1 = 0.0; Vgs_fp1 = 0.0; Vds_fp1 = 0.0; Ids_fp1 = 0.0;
            Vg0_fp1s = 0.0; Cg_fp1s = 0.0; psis_fp1s = 0.0; psid_fp1s = 0.0; psim_fp1s = 0.0; psisd_fp1s = 0.0; qg_fp1s = 0.0; qd_fp1s = 0.0;
            qs_fp1s = 0.0; Vgs_fp1s = 0.0; Vds_fp1s = 0.0; Ids_fp1s = 0.0;
            Vg0_fp2 = 0.0; Cg_fp2 = 0.0; psis_fp2 = 0.0; psid_fp2 = 0.0; psim_fp2 = 0.0; psisd_fp2 = 0.0; qg_fp2 = 0.0; qd_fp2 = 0.0;
            qs_fp2 = 0.0; Vgs_fp2 = 0.0; Vds_fp2 = 0.0; Ids_fp2 = 0.0;
            Vg0_fp2s = 0.0; Cg_fp2s = 0.0; psis_fp2s = 0.0; psid_fp2s = 0.0; psim_fp2s = 0.0; psisd_fp2s = 0.0; qg_fp2s = 0.0; qd_fp2s = 0.0;
            qs_fp2s = 0.0; Vgs_fp2s = 0.0; Vds_fp2s = 0.0; Ids_fp2s = 0.0;
            Vg0_fp3 = 0.0; Cg_fp3 = 0.0; psis_fp3 = 0.0; psid_fp3 = 0.0; psim_fp3 = 0.0; psisd_fp3 = 0.0; qg_fp3 = 0.0; qd_fp3 = 0.0;
            qs_fp3 = 0.0; Vgs_fp3 = 0.0; Vds_fp3 = 0.0; Ids_fp3 = 0.0;
            Vg0_fp3s = 0.0; Cg_fp3s = 0.0; psis_fp3s = 0.0; psid_fp3s = 0.0; psim_fp3s = 0.0; psisd_fp3s = 0.0; qg_fp3s = 0.0; qd_fp3s = 0.0;
            qs_fp3s = 0.0; Vgs_fp3s = 0.0; Vds_fp3s = 0.0; Ids_fp3s = 0.0;
            Vg0_fp4 = 0.0; Cg_fp4 = 0.0; psis_fp4 = 0.0; psid_fp4 = 0.0; psim_fp4 = 0.0; psisd_fp4 = 0.0; qg_fp4 = 0.0; qd_fp4 = 0.0;
            qs_fp4 = 0.0; Vgs_fp4 = 0.0; Vds_fp4 = 0.0; Ids_fp4 = 0.0;
            Vg0_fp4s = 0.0; Cg_fp4s = 0.0; psis_fp4s = 0.0; psid_fp4s = 0.0; psim_fp4s = 0.0; psisd_fp4s = 0.0; qg_fp4s = 0.0; qd_fp4s = 0.0;
            qs_fp4s = 0.0; Vgs_fp4s = 0.0; Vds_fp4s = 0.0; Ids_fp4s = 0.0;
            Igs = 0.0; Igd = 0.0;
            cr = 0.01;
            crm = 0.01;
            Rdrain = 0.0; Rsource = 0.0; gdpr = 0.0; gspr = 0.0;
            sigvdsfp1 = 1.0;
            sigvdsfp2 = 1.0;
            sigvdsfp3 = 1.0;
            sigvdsfp4 = 1.0;
            sigvdsfp1s = 1.0;
            sigvdsfp2s = 1.0;
            sigvdsfp3s = 1.0;
            sigvdsfp4s = 1.0;
            mvgs = 0.0; mvgd = 0.0; efield=0.0; rigsdio_t = 0.0; rigddio_t = 0.0;
            vbis_t=0.0; vbid_t = 0.0;
            njgs_t=1.0;
            njgd_t=1.0;
            Grgeltd=1.0e3;
            Grgeltd1=1.0e3;
            Grgeltd2=1.0e3;
            voffdlag=0.0; voffglag=0.0; u0glag=0.0; ns0ddlag=0.0; ns0sdlag=0.0; vsatglag=0.0;

            if ($port_connected(dt) == 0) begin
                if (shmod == 0 || rth0 == 0.0) begin
                    Temp(dt) <+ 0.0;
                end else begin
                    $strobe("5 terminal Module, while 't' node is not connected, SH is activated.");
                end
            end
////////// Temperature Conversion From Celsius To Kelvin //////////
            Tnom = tnom + `P_CELSIUS0;

////////// Terminal Voltage Conditioning //////////
            Vds_noswap = V(di,si);
            Vgs_noswap = V(gi,si);
            Vgd_noswap = V(gi,di);
            Vbs        = V(b,si);
            sigvds = 1.0;
            if (Vds_noswap < 0.0) begin
                sigvds = -1.0;
                Vds = sigvds*Vds_noswap ;
                Vgs = Vgd_noswap ;
            end else begin
                Vds = Vds_noswap ;
                Vgs = Vgs_noswap ;
            end
            Vdsx = sqrt(Vds*Vds + 0.01) - 0.1;
            Tdev = $temperature + Temp(rth) + dtemp;
            Vth  = `KboQ * Tdev ;
////////// Trap Models //////////
            case (trapmod)
                0:begin
                    V(trap1) <+ 0.0;
                    V(trap2) <+ 0.0;
                    V(nt)  <+ 0.0;
                    V(ntg) <+ 0.0;
                    V(n1)  <+ 0.0;
                    V(n2)  <+ 0.0;
                end
                1:begin
                    V(trap2) <+ Vds*Vds;
                    I(trap2,trap1) <+ idio*(lexp(V(trap2,trap1)/10.0) - 1.0);
                    I(trap1) <+ cdlag*ddt(V(trap1));
                    I(trap1) <+ V(trap1)/rdlag;
                    vcap = V(trap1);
                    vcap = smoothminx(vcap,Vth,deltax);
                    voff_cap = atrapvoff + btrapvoff*lexp(-1.0/vcap);
                    rs_cap = atraprs + btraprs*lexp(-1.0/vcap);
                    rd_cap = atraprd + btraprd*lexp(-1.0/vcap);
                    eta0_cap = atrapeta0 + btrapeta0*lexp(-1.0/vcap);
                    V(nt)  <+ 0.0;
                    V(ntg) <+ 0.0;
                    V(n1)  <+ 0.0;
                    V(n2)  <+ 0.0;
                end
                2:begin
                    vdgeff1 = lexp(a1*(-V(g,s)));
                    I(trap1) <+ V(trap1)/rtrap1;
                    I(trap1) <+ -1.0*vdgeff1;
                    I(trap1) <+ ctrap1*ddt(V(trap1));
                    I(trap2) <+ V(trap2)/rtrap2;
                    I(trap2) <+ -1.0*V(d,s);
                    I(trap2) <+ ctrap2*ddt(V(trap2));
                    voff_trap = vofftr*V(trap2);
                    ron_trap = -rontr1 * V(trap1)+rontr2 * V(trap2) + rontr3;
                    cdscd_trap = cdscdtr*V(trap2);
                    eta0_trap = eta0tr*V(trap2);
                    V(nt)  <+ 0.0;
                    V(ntg) <+ 0.0;
                    V(n1)  <+ 0.0;
                    V(n2)  <+ 0.0;
                end
                3:begin
                    vdg = V(d,g);
                    t1 = (vdlr1/(1.0 + vdg*wd))*vdg;
                    t2 = vdlr2*(vdg - vtb);                                                   //vtb for break between two linear regions
                    vdgeff = 0.5*(t1+t2 + sqrt((t1-t2)*(t1-t2) + 0.25*deltax*deltax));        //Max function for t1 or t2
                    if (V(g) > voff) begin                                                    //Charge-Discharge Condition
                        ct = ctrap3;
                    end else begin
                        ct = 1.0e-09;
                    end
                    I(trap1) <+ V(trap1)/rtrap3;
                    I(trap1) <+ -1.0*vdgeff;
                    I(trap1) <+ ct*ddt(V(trap1));
                    Rtrap = V(trap1)/vatrap;
                    Rtrap_t = Rtrap*pow((Tdev/Tnom),talpha);                                   //Temperature Dependence
                    V(trap2) <+ 0.0;
                    V(nt)  <+ 0.0;
                    V(ntg) <+ 0.0;
                    V(n1)  <+ 0.0;
                    V(n2)  <+ 0.0;
                end
                4: begin
                    V(trap1) <+ 0.0;
                    V(trap2) <+ 0.0;
                    t0 = abs(V(d,s));
                    V(n1) <+ t0;
                    Rnon = remi/(1 + arcap*exp(V(n1,nt)/brcap));
                    I(n1,nt) <+ V(n1,nt)/Rnon ;
                    I(nt)<+ cdlag*ddt(V(nt)) + 1.0e-12*V(nt);
                    t1 = abs(V(g,s));
                    V(n2) <+ t1;
                    Rnong = remig/(1 + arcapg*exp(V(n2,ntg)/brcapg));
                    I(n2,ntg) <+ V(n2,ntg)/Rnong ;
                    I(ntg)<+ cglag*ddt(V(ntg)) + 1.0e-12*V(ntg);
                    vaux = V(nt) - abs(V(d,s));
                    vaux = smoothminx(vaux,0.0,1.0e-30);
                    vauxg = V(ntg) - abs(V(g,s));
                    vauxg = smoothminx(vauxg,0.0,1.0e-30);
                    `PCAL(vaux,vdlmax,voff,dlvoff, voffdlag)
                    `PCAL(vauxg,vglmax,voff,glvoff, voffglag)
                    `PCAL(vauxg,vglmax,u0,glu0, u0glag)
                    `PCAL(vauxg,vglmax,vsat,glvsat, vsatglag)
                    `PCAL(vaux,vdlmax,ns0accs,dlns0s, ns0sdlag)
                    `PCAL(vaux,vdlmax,ns0accd,dlns0d, ns0ddlag)
                end
            endcase
////////// End of Trap Models //////////

////////// Calculation For Physical Quantities Required In SP Calculation //////////
            Cg = epsilon/tbar;
            Cepi = epsilon/tepi;
            cdsc = 1.0 + nfactor + (cdscd+cdscd_trap)*Vdsx; //Sub-threshold Slope
            Vtv = `KboQ*Tdev*cdsc;
            Voff_dibl = voff + voffdlag + voffglag - (eta0 + eta0_trap - eta0_cap)*(Vdsx*vdscale)/sqrt(Vdsx*Vdsx + vdscale*vdscale);
            tempr = Tdev/Tnom ;
            Voff_dibl_temp = Voff_dibl - (tempr - 1.0)*kt1 + voff_trap + voff_cap + (Cepi/(Cepi+Cg))*asub*Vbs;

////////// VGMin and VG0 Calculation //////////
            `VG0(l,w,Voff_dibl_temp,imin,Vgs,Vtv,Vg0)

////////// Surface Potential Calculation Source Side //////////
            `PSIS(Cg,Vg0,gamma0i,gamma1i,Vtv,  beta,ALPHAN,ALPHAD,Cch,psis)

////////// Surface Potential Drain Side //////////
            u0_i = u0 - u0glag;
            vsat_i = vsat - vsatglag;
            `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0_i,ute,vsat_i,at,Cg,psis,Vg0,ua,ub,l,Vds,gamma0i,gamma1i,   mulf_tdev,Vdeff,psid)
            psim = 0.5*(psis + psid);
            psisd = psid - psis ;
            `IDS(Vg0,psim,psisd,Cg,l,Vdsx,w,nf,Vtv,mulf_tdev,Vdeff,   Ids)
            aslt = asl*(1.0 + kasl*(tempr - 1.0));
            nslt = nsl*(1.0 + knsl*(tempr - 1.0));
            bvdslt = bvdsl*(1.0 + kbvdsl*(tempr - 1.0));
            `ISL(Vdsx,Vth,w,nf,aslt,nslt,bvdslt,  isl)
            I(di,si) <+ sigvds*(Ids+isl) + gdsmin*V(di,si);

////////// Terminal Charge Equations //////////
            `QGI(Vg0,psis,psid,psim,Cg,l,qm0i,bdosi,adosi,tbar,Vtv,w,nf,   Cg_qme,qgint)
            `QDI(Vg0,psim,psis,psid,psisd,l,Vtv,w,nf,Cg_qme,   qdint)
            qsint = -1.0*qgint -1.0*qdint; //Source Charge
            if (sigvds < 0.0) begin
                t1 = qsint;
                qsint = qdint;
                qdint = t1;
            end

////////// Gate Current Model //////////
            case (gatemod)
                0:begin
                    Igs = 0.0; Igd = 0.0;
                end
                1:begin
                    t0 = V(gi, si)/(njgs*`KboQ*Tdev);
                    t3 = igsdio + (Tdev/Tnom - 1.0)* ktgs;
                    Igs = w*l*nf*abs(t3)*(lexp(t0)-1.0);
                    t0 = V(gi, di)/(njgd*`KboQ*Tdev);
                    t3 = igddio + (Tdev/Tnom - 1.0)* ktgd;
                    Igd = w*l*nf*abs(t3)*(lexp(t0)-1.0);
                end
                2:begin
                    vbis_t = vbis + (Tdev/Tnom-1)*ktvbis;
                    njgs_t = njgs + (Tdev/Tnom-1)*ktnjgs;
                    rnjgs_t = rnjgs + (Tdev/Tnom-1)*ktrnjgs;
                    t0 = (V(gi, si)-vbis_t)/(njgs_t*`KboQ*Tnom);
                    t3 = igsdio*exp(ktgs*(Tdev/Tnom-1));
                    Igs = w*l*nf*abs(t3)*(lexp(t0)-1.0);
                    mvgs = hypmax(-V(gi,si),0.0,0.001);
                    efield = mvgs/tbar;
                    t0 = (sqrt(mvgs) + ebreaks);
                    t1 = t0/(rnjgs_t*`KboQ*Tnom);
                    rigsdio_t = rigsdio*exp(rktgs*(Tdev/Tnom-1));
                    Igs = Igs*(1.0 + efield*rigsdio_t*lexp(t1));
                    vbid_t = vbid + (Tdev/Tnom-1)*ktvbid;
                    njgd_t = njgd + (Tdev/Tnom-1)*ktnjgd;
                    rnjgd_t = rnjgd + (Tdev/Tnom-1)*ktrnjgd;
                    t0 = (V(gi, di)-vbid_t)/(njgd_t*`KboQ*Tnom);
                    t3 = igddio*exp(ktgd*(Tdev/Tnom-1));
                    Igd = w*l*nf*abs(t3)*(lexp(t0)-1.0);
                    mvgd = hypmax(-V(gi,di),0.0,0.001);
                    efield = mvgd/tbar;
                    t0 = (sqrt(mvgd) + ebreakd);
                    t0 = t0/(rnjgd_t*`KboQ*Tnom);
                    rigddio_t = rigddio*exp(rktgd*(Tdev/Tnom-1));
                    Igd = Igd*(1.0 + efield*rigddio_t*lexp(t0));
                end
            endcase
            I(gi,si) <+ Igs;
            I(gi,di) <+ Igd;
////////// Access Region Non-linear Resistance Model //////////

            ars_chk = $param_given(ars);
            ard_chk = $param_given(ard);
            if (rdsmod == 1) begin
                ns0_t = ns0accs*(1.0 - kns0*(Tdev/Tnom-1.0)) -ns0sdlag;
                ns0_t = hypmax(ns0_t, 1.0, 1.0e-3);
                qsacc = `P_Q*ns0_t*(1.0 + k0accs*vgopacc);
                vsataccs_t = vsataccs*pow((Tdev/Tnom),ats); //Vsat Temperature Dependence
                isatacc = w*nf*qsacc*vsataccs_t;
                u0accs_t = u0accs*pow((Tdev/Tnom),utes);    //Mobility Temperature Dependence
                rs0 = lsg/(w*nf*qsacc*u0accs_t);
                if (ars_chk!=0) begin
                    `isat(Ids,isatacc,ars, idseff)
                    t2 = 1.0 - (idseff/isatacc);
                end else begin
                    cr  = abs(Ids/isatacc);
                    crm = smoothmax(cr,0.9,0.1);
                    t0 = pow(crm,mexpaccs);
                    t1 = 1.0 - t0;
                    t2 = pow(t1,1.0/mexpaccs);
                end
                rsbias = rs0;
                rsbias = rs0/t2;
                rsc_t = rsc*(1.0+krsc*(Tdev/Tnom-1.0));
                Rsource = rsc_t/(w*nf) + rsbias + rs_cap;
                ns0_t = ns0accd*(1.0 - kns0*(Tdev/Tnom-1.0)) -ns0ddlag;
                ns0_t = hypmax(ns0_t, 1.0, 1.0e-3);
                qsacc = `P_Q*ns0_t*(1.0 + k0accd*vgopacc);
                isatacc = w*nf*qsacc*vsataccs_t;
                u0accd_t = u0accd*pow((Tdev/Tnom),uted);    //Mobility Temperature Dependence
                rd0 = ldg/(w*nf*qsacc*u0accd_t);
                if (ard_chk!=0) begin
                    `isat(Ids,isatacc,ard, idseff)
                    t2 = 1.0 - (idseff/isatacc);
                end else begin
                    cr  = abs(Ids/isatacc);
                    crm = smoothmax(cr,0.9,0.1);
                    t0 = pow(crm,mexpaccd);
                    t1 = 1.0 - t0;
                    t2 = pow(t1,1.0/mexpaccd);
                end
                rdbias = rd0/t2;
                rdc_t = rdc*(1.0+krdc*(Tdev/Tnom-1.0));
                Rdrain = rdc_t/(w*nf) + rdbias + Rtrap_t + ron_trap + rd_cap;
                gdpr = 1.0 / Rdrain;
                gspr = 1.0 / Rsource;
                if (fastfpmod == 0) begin
                    I(d, `IntrinsicDrain_fp4) <+ gdpr*V(d, `IntrinsicDrain_fp4);
                    I(`IntrinsicSource_fp4s,s) <+ gspr*V(`IntrinsicSource_fp4s,s);
                end else begin
                    I(d, di) <+ gdpr*V(d, di);
                    I(si,s) <+ gspr*V(si,s);
                end
            end else begin
                if (fastfpmod == 0) begin
                    V(d, `IntrinsicDrain_fp4) <+ 0.0;
                    V(s,`IntrinsicSource_fp4s) <+ 0.0;
                end else begin
                    V(d,di) <+ 0.0;
                    V(si,s) <+ 0.0;
                end
            end
//////////  Noise Modeling  //////////

////////// Thermal Noise Model //////////
            if (tnmod==1) begin
                ThSid = (tnsc/(max(Ids,1e-10)*l*l))*(4.0*`KboQ*`P_Q*Tdev*`P_Q*w*nf*Cg*`P_Q*w*nf*Cg)*((mu_eff/vf)*(mu_eff/vf))*(Vg0*Vg0*psisd+((psid*psid*psid-psis*psis*psis)/3)-Vg0*(psid*psid-psis*psis)); //Channel Thermal Noise PSD
                I(di, si) <+ white_noise(ThSid, "ids");
                if (rdsmod==1) begin
                    if (fastfpmod == 0) begin
                        I(d, `IntrinsicDrain_fp4) <+ white_noise(4.0 * Vth * `P_Q * gdpr, "rd");
                        I(s, `IntrinsicSource_fp4s) <+ white_noise(4.0 * Vth * `P_Q * gspr, "rs");
                    end else begin
                        I(d, di) <+ white_noise(4.0 * Vth * `P_Q * gdpr, "rd");
                        I(s, si) <+ white_noise(4.0 * Vth * `P_Q * gspr, "rs");
                    end
                end
            end
////////// Shot Noise Model ///////////
            if (gatemod!= 0) begin
                I(gi, si) <+ white_noise(2.0 * `P_Q * abs(Igs), "igs");
                I(gi, di) <+ white_noise(2.0 * `P_Q * abs(Igd), "igd");
            end
////////// FP1 Current Model //////////
            `ifdef __FP1MOD__
                if (fastfpmod == 0) begin
                    if (fp1mod != 0) begin
                        Vds_noswapfp1 = V(fp1,di);
                        if (fp1mod == 1) begin
                            Vgs_noswapfp1 = V(gi,di);
                            Vgd_noswapfp1 = V(gi,fp1);
                        end else begin
                            Vgs_noswapfp1 = V(s,di);
                            Vgd_noswapfp1 = V(s,fp1);
                        end
                        sigvdsfp1 = 1.0;
                        if (Vds_noswapfp1 < 0.0) begin
                            sigvdsfp1 = -1.0;
                            Vds_fp1 = sigvdsfp1*Vds_noswapfp1 ;
                            Vgs_fp1 = Vgd_noswapfp1 ;
                        end else begin
                            Vds_fp1 = Vds_noswapfp1 ;
                            Vgs_fp1 = Vgs_noswapfp1 ;
                        end
                        Vdsx_fp1 = sqrt(Vds_fp1*Vds_fp1 + 0.01) - 0.1;
                        cdsc = 1.0 + nfactorfp1 + cdscdfp1*Vdsx_fp1; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp1 + (Tdev/Tnom - 1.0)*ktfp1 - (eta0fp1)*(Vdsx_fp1*vdscalefp1)/sqrt(Vdsx_fp1*Vdsx_fp1 + vdscalefp1*vdscalefp1);
                        Cg_fp1 = epsilon/dfp1;
                        `VG0(lfp1,w,Voff_dibl_temp,iminfp1,Vgs_fp1,Vtv,Vg0_fp1)
                        `PSIS(Cg_fp1,Vg0_fp1,gamma0fp1,gamma1fp1,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp1)
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp1,ute,vsatfp1,at,Cg_fp1,psis_fp1,Vg0_fp1,ua,ub,lfp1,Vds_fp1,gamma0fp1,gamma1fp1,   mulf_tdev,Vdeff,psid_fp1)
                        psim_fp1 = 0.5*(psis_fp1 + psid_fp1);
                        psisd_fp1 = psid_fp1 - psis_fp1;
                        `IDS(Vg0_fp1,psim_fp1,psisd_fp1,Cg_fp1,lfp1,Vdsx_fp1,w,nf,Vtv,mulf_tdev,Vdeff,   Ids_fp1)
                        I(fp1,di) <+ sigvdsfp1*Ids_fp1 + gdsmin*V(fp1,di);
                        `QGI(Vg0_fp1,psis_fp1,psid_fp1,psim_fp1,Cg_fp1,lfp1,qm0fp1,bdosfp1,adosfp1,dfp1,Vtv,w,nf,   Cg_qme,qg_fp1)
                        `QDI(Vg0_fp1,psim_fp1,psis_fp1,psid_fp1,psisd_fp1,lfp1,Vtv,w,nf,Cg_qme,   qd_fp1)
                        qs_fp1 = -1.0*qg_fp1 -1.0*qd_fp1;
                        if (sigvdsfp1 < 0.0) begin
                            t1 = qs_fp1;
                            qs_fp1 = qd_fp1;
                            qd_fp1 = t1;
                        end
                    end else begin
                        V(fp1,di) <+ 0.0;
                        qg_fp1 = 0;
                        qd_fp1 = 0;
                    end
                end else begin
                    if (fp1mod != 0) begin
                        if (fp1mod == 1) begin
                            Vgs_noswapfp1 = V(gi,di);
                        end else begin
                            Vgs_noswapfp1 = V(s,di);
                        end
                        Vgs_fp1 = Vgs_noswapfp1;
                        sigvdsfp1 = 1.0;
                        cdsc = 1.0 + nfactorfp1 ; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp1 + (Tdev/Tnom - 1.0)*ktfp1 ;
                        Cg_fp1 = epsilon/dfp1;
                        `VG0(lfp1,w,Voff_dibl_temp,iminfp1,Vgs_fp1,Vtv,Vg0_fp1)
                        `PSIS(Cg_fp1,Vg0_fp1,gamma0fp1,gamma1fp1,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp1)
                        Vds_fp1 = 0.0;
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp1,ute,vsatfp1,at,Cg_fp1,psis_fp1,Vg0_fp1,ua,ub,lfp1,Vds_fp1,gamma0fp1,gamma1fp1,   mulf_tdev,Vdeff,psid_fp1)
                        psim_fp1 = 0.5*(psis_fp1 + psid_fp1);
                        psisd_fp1 = psid_fp1 - psis_fp1;
                        `QGI(Vg0_fp1,psis_fp1,psid_fp1,psim_fp1,Cg_fp1,lfp1,qm0fp1,bdosfp1,adosfp1,dfp1,Vtv,w,nf,   Cg_qme,qg_fp1)
                        `QDI(Vg0_fp1,psim_fp1,psis_fp1,psid_fp1,psisd_fp1,lfp1,Vtv,w,nf,Cg_qme,   qd_fp1)
                        qs_fp1 = -1.0*qg_fp1 -1.0*qd_fp1;
                    end else begin
                        qg_fp1 = 0;
                        qd_fp1 = 0;
                    end
                end
            `endif
///////////// FP1 Source side current model //////////////////////////////////////////////
            `ifdef __FP1SMOD__
                if (fastfpmod == 0) begin
                    if (fp1smod != 0) begin
                        Vds_noswapfp1s = V(si,fp1s);
                        if (fp1smod == 1) begin
                            Vgs_noswapfp1s = V(gi,fp1s);
                            Vgd_noswapfp1s = V(gi,si);
                        end else begin
                            Vgs_noswapfp1s = V(s,fp1s);
                            Vgd_noswapfp1s = V(s,si);
                        end
                        sigvdsfp1s = 1.0;
                        if (Vds_noswapfp1s < 0.0) begin
                            sigvdsfp1s = -1.0;
                            Vds_fp1s = sigvdsfp1s*Vds_noswapfp1s ;
                            Vgs_fp1s = Vgd_noswapfp1s ;
                        end else begin
                            Vds_fp1s = Vds_noswapfp1s ;
                            Vgs_fp1s = Vgs_noswapfp1s ;
                        end
                        Vdsx_fp1s = sqrt(Vds_fp1s*Vds_fp1s + 0.01) - 0.1;
                        cdsc = 1.0 + nfactorfp1 + cdscdfp1*Vdsx_fp1s; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp1 + (Tdev/Tnom - 1.0)*ktfp1 - (eta0fp1)*(Vdsx_fp1s*vdscalefp1)/sqrt(Vdsx_fp1s*Vdsx_fp1s + vdscalefp1*vdscalefp1);
                        Cg_fp1s = epsilon/dfp1;
                        `VG0(lfp1,w,Voff_dibl_temp,iminfp1,Vgs_fp1s,Vtv,Vg0_fp1s)
                        `PSIS(Cg_fp1s,Vg0_fp1s,gamma0fp1,gamma1fp1,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp1s)
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp1,ute,vsatfp1,at,Cg_fp1s,psis_fp1s,Vg0_fp1s,ua,ub,lfp1,Vds_fp1s,gamma0fp1,gamma1fp1,   mulf_tdev,Vdeff,psid_fp1s)
                        psim_fp1s = 0.5*(psis_fp1s + psid_fp1s);
                        psisd_fp1s = psid_fp1s - psis_fp1s;
                        `IDS(Vg0_fp1s,psim_fp1s,psisd_fp1s,Cg_fp1s,lfp1,Vdsx_fp1s,w,nf,Vtv,mulf_tdev,Vdeff,   Ids_fp1s)
                        I(si,fp1s) <+ sigvdsfp1s*Ids_fp1s + gdsmin*V(si,fp1s);
                        `QGI(Vg0_fp1s,psis_fp1s,psid_fp1s,psim_fp1s,Cg_fp1s,lfp1,qm0fp1,bdosfp1,adosfp1,dfp1,Vtv,w,nf,   Cg_qme,qg_fp1s)
                        `QDI(Vg0_fp1s,psim_fp1s,psis_fp1s,psid_fp1s,psisd_fp1s,lfp1,Vtv,w,nf,Cg_qme,   qd_fp1s)
                        qs_fp1s = -1.0*qg_fp1s -1.0*qd_fp1s;
                        if (sigvdsfp1s < 0.0) begin
                            t1 = qs_fp1s;
                            qs_fp1s = qd_fp1s;
                            qd_fp1s = t1;
                        end
                    end else begin
                        V(si,fp1s) <+ 0.0;
                        qg_fp1s = 0;
                        qd_fp1s = 0;
                    end
                end else begin
                    if (fp1smod != 0) begin
                        if (fp1smod == 1) begin
                            Vgs_noswapfp1s = V(gi,si);
                        end else begin
                            Vgs_noswapfp1s = V(s,si);
                        end
                        Vg0_fp1s = Vgs_noswapfp1s;
                        cdsc = 1.0 + nfactorfp1; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp1 + (Tdev/Tnom - 1.0)*ktfp1;
                        Cg_fp1s = epsilon/dfp1;
                        `VG0(lfp1,w,Voff_dibl_temp,iminfp1,Vgs_fp1s,Vtv,Vg0_fp1s)
                        `PSIS(Cg_fp1s,Vg0_fp1s,gamma0fp1,gamma1fp1,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp1s)
                        Vds_fp1s = 0.0;
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp1,ute,vsatfp1,at,Cg_fp1s,psis_fp1s,Vg0_fp1s,ua,ub,lfp1,Vds_fp1s,gamma0fp1,gamma1fp1,   mulf_tdev,Vdeff,psid_fp1s)
                        psim_fp1s = 0.5*(psis_fp1s + psid_fp1s);
                        psisd_fp1s = psid_fp1s - psis_fp1s;
                        `QGI(Vg0_fp1s,psis_fp1s,psid_fp1s,psim_fp1s,Cg_fp1s,lfp1,qm0fp1,bdosfp1,adosfp1,dfp1,Vtv,w,nf,   Cg_qme,qg_fp1s)
                        `QDI(Vg0_fp1s,psim_fp1s,psis_fp1s,psid_fp1s,psisd_fp1s,lfp1,Vtv,w,nf,Cg_qme,   qd_fp1s)
                        qs_fp1s = -1.0*qg_fp1s -1.0*qd_fp1s;
                    end else begin
                        qg_fp1s = 0;
                        qd_fp1s = 0;
                    end
                end
            `endif
////////// FP2 Current Model //////////
            `ifdef __FP2MOD__
                if (fastfpmod == 0) begin
                    if (fp2mod != 0) begin
                        Vds_noswapfp2 = V(fp2,`IntrinsicDrain_fp1);
                        if (fp2mod == 1) begin
                            Vgs_noswapfp2 = V(gi,`IntrinsicDrain_fp1);
                            Vgd_noswapfp2 = V(gi,fp2);
                        end else begin
                            Vgs_noswapfp2 = V(s,`IntrinsicDrain_fp1);
                            Vgd_noswapfp2 = V(s,fp2);
                        end
                        sigvdsfp2 = 1.0;
                        if (Vds_noswapfp2 < 0.0) begin
                            sigvdsfp2 = -1.0;
                            Vds_fp2 = sigvdsfp2*Vds_noswapfp2 ;
                            Vgs_fp2 = Vgd_noswapfp2 ;
                        end else begin
                            Vds_fp2 = Vds_noswapfp2 ;
                            Vgs_fp2 = Vgs_noswapfp2 ;
                        end

                        Vdsx_fp2 = sqrt(Vds_fp2*Vds_fp2 + 0.01) - 0.1;
                        cdsc = 1.0 + nfactorfp2 + cdscdfp2*Vdsx_fp2; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp2 - (Tdev/Tnom - 1.0)*ktfp2 - (eta0fp2)*(Vdsx_fp2*vdscalefp2)/sqrt(Vdsx_fp2*Vdsx_fp2 + vdscalefp2*vdscalefp2);
                        Cg_fp2 = epsilon/(dfp2);
                        `VG0(lfp2,w,Voff_dibl_temp,iminfp2,Vgs_fp2,Vtv,Vg0_fp2)
                        `PSIS(Cg_fp2,Vg0_fp2,gamma0fp2,gamma1fp2,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp2)
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp2,ute,vsatfp2,at,Cg_fp2,psis_fp2,Vg0_fp2,ua,ub,lfp2,Vds_fp2,gamma0fp2,gamma1fp2,   mulf_tdev,Vdeff,psid_fp2)
                        psim_fp2 = 0.5*(psis_fp2 + psid_fp2);
                        psisd_fp2 = psid_fp2 - psis_fp2 ;
                        `IDS(Vg0_fp2,psim_fp2,psisd_fp2,Cg_fp2,lfp2,Vdsx_fp2,w,nf,Vtv,mulf_tdev,Vdeff,   Ids_fp2)
                        I(fp2,`IntrinsicDrain_fp1) <+ sigvdsfp2*Ids_fp2 + gdsmin*V(fp2,`IntrinsicDrain_fp1);
                        `QGI(Vg0_fp2,psis_fp2,psid_fp2,psim_fp2,Cg_fp2,lfp2,qm0fp2,bdosfp2,adosfp2,dfp2,Vtv,w,nf,   Cg_qme,qg_fp2)
                        `QDI(Vg0_fp2,psim_fp2,psis_fp2,psid_fp2,psisd_fp2,lfp2,Vtv,w,nf,Cg_qme,   qd_fp2)
                        qs_fp2 = -1.0*qg_fp2 -1.0*qd_fp2;
                        if (sigvdsfp2 < 0.0) begin
                            t1 = qs_fp2;
                            qs_fp2 = qd_fp2;
                            qd_fp2 = t1;
                        end
                    end else begin
                        V(fp2,`IntrinsicDrain_fp1) <+ 0.0;
                        qg_fp2 = 0;
                        qd_fp2 = 0;
                    end
                end else begin
                    if (fp2mod != 0) begin
                        if (fp2mod == 1) begin
                            Vgs_noswapfp2 = V(gi,di);
                        end else begin
                            Vgs_noswapfp2 = V(s,di);
                        end
                        sigvdsfp2 = 1.0;
                        Vg0_fp2 = Vgs_noswapfp2;
                        cdsc = 1.0 + nfactorfp2; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp2 - (Tdev/Tnom - 1.0)*ktfp2 ;
                        Cg_fp2 = epsilon/(dfp2);
                        `VG0(lfp2,w,Voff_dibl_temp,iminfp2,Vgs_fp2,Vtv,Vg0_fp2)
                        `PSIS(Cg_fp2,Vg0_fp2,gamma0fp2,gamma1fp2,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp2)
                        Vds_fp2 = 0.0;
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp2,ute,vsatfp2,at,Cg_fp2,psis_fp2,Vg0_fp2,ua,ub,lfp2,Vds_fp2,gamma0fp2,gamma1fp2,   mulf_tdev,Vdeff,psid_fp2)
                        psim_fp2 = 0.5*(psis_fp2 + psid_fp2);
                        psisd_fp2 = psid_fp2 - psis_fp2 ;
                        `QGI(Vg0_fp2,psis_fp2,psid_fp2,psim_fp2,Cg_fp2,lfp2,qm0fp2,bdosfp2,adosfp2,dfp2,Vtv,w,nf,   Cg_qme,qg_fp2)
                        `QDI(Vg0_fp2,psim_fp2,psis_fp2,psid_fp2,psisd_fp2,lfp2,Vtv,w,nf,Cg_qme,   qd_fp2)
                        qs_fp2 = -1.0*qg_fp2 -1.0*qd_fp2;
                    end else begin
                        qg_fp2 = 0;
                        qd_fp2 = 0;
                    end
                end
            `endif
///////////// FP2 Source side current model //////////////////////////////////////////////
            `ifdef __FP2SMOD__
                if (fastfpmod == 0) begin
                    if (fp2smod != 0) begin
                        Vds_noswapfp2s = V(`IntrinsicSource_fp1s,fp2s);
                        if (fp2smod == 1) begin
                            Vgs_noswapfp2s = V(gi,fp2s);
                            Vgd_noswapfp2s = V(gi,`IntrinsicSource_fp1s);
                        end else begin
                            Vgs_noswapfp2s = V(s,fp2s);
                            Vgd_noswapfp2s = V(s,`IntrinsicSource_fp1s);
                        end
                        sigvdsfp2s = 1.0;
                        if (Vds_noswapfp2s < 0.0) begin
                            sigvdsfp2s = -1.0;
                            Vds_fp2s = sigvdsfp2s*Vds_noswapfp2s ;
                            Vgs_fp2s = Vgd_noswapfp2s ;
                        end else begin
                            Vds_fp2s = Vds_noswapfp2s ;
                            Vgs_fp2s = Vgs_noswapfp2s ;
                        end

                        Vdsx_fp2s = sqrt(Vds_fp2s*Vds_fp2s + 0.01) - 0.1;
                        cdsc = 1.0 + nfactorfp2 + cdscdfp2*Vdsx_fp2s; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp2 + (Tdev/Tnom - 1.0)*ktfp2 - (eta0fp2)*(Vdsx_fp2s*vdscalefp2)/sqrt(Vdsx_fp2s*Vdsx_fp2s + vdscalefp2*vdscalefp2);
                        Cg_fp2s = epsilon/dfp2;
                        `VG0(lfp2,w,Voff_dibl_temp,iminfp2,Vgs_fp2s,Vtv,Vg0_fp2s)
                        `PSIS(Cg_fp2s,Vg0_fp2s,gamma0fp2,gamma1fp2,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp2s)
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp2,ute,vsatfp2,at,Cg_fp2s,psis_fp2s,Vg0_fp2s,ua,ub,lfp2,Vds_fp2s,gamma0fp2,gamma1fp2,   mulf_tdev,Vdeff,psid_fp2s)
                        psim_fp2s = 0.5*(psis_fp2s + psid_fp2s);
                        psisd_fp2s = psid_fp2s - psis_fp2s;
                        `IDS(Vg0_fp2s,psim_fp2s,psisd_fp2s,Cg_fp2s,lfp2,Vdsx_fp2s,w,nf,Vtv,mulf_tdev,Vdeff,   Ids_fp2s)
                        I(`IntrinsicSource_fp1s,fp2s) <+ sigvdsfp2s*Ids_fp2s + gdsmin*V(`IntrinsicSource_fp1s,fp2s);
                        `QGI(Vg0_fp2s,psis_fp2s,psid_fp2s,psim_fp2s,Cg_fp2s,lfp2,qm0fp2,bdosfp2,adosfp2,dfp2,Vtv,w,nf,   Cg_qme,qg_fp2s)
                        `QDI(Vg0_fp2s,psim_fp2s,psis_fp2s,psid_fp2s,psisd_fp2s,lfp2,Vtv,w,nf,Cg_qme,   qd_fp2s)
                        if (sigvdsfp2s < 0.0) begin
                            t1 = qs_fp2s;
                            qs_fp2s = qd_fp2s;
                            qd_fp2s = t1;
                        end
                        qs_fp2s = -1.0*qg_fp2s -1.0*qd_fp2s;
                    end else begin
                        V(`IntrinsicSource_fp1s,fp2s) <+ 0.0;
                        qg_fp2s = 0;
                        qd_fp2s = 0;
                    end
                end else begin
                    if (fp2smod != 0) begin
                        if (fp2smod == 1) begin
                            Vgs_noswapfp2s = V(gi,si);
                        end else begin
                            Vgs_noswapfp2s = V(s,si);
                        end
                        sigvdsfp2s = 1.0;
                        Vgs_fp2s = Vgs_noswapfp2s;
                        cdsc = 1.0 + nfactorfp2 ; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp2 + (Tdev/Tnom - 1.0)*ktfp2 ;
                        Cg_fp2s = epsilon/dfp2;
                        `VG0(lfp2,w,Voff_dibl_temp,iminfp2,Vgs_fp2s,Vtv,Vg0_fp2s)
                        `PSIS(Cg_fp2s,Vg0_fp2s,gamma0fp2,gamma1fp2,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp2s)
                        Vds_fp2s = 0.0;
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp2,ute,vsatfp2,at,Cg_fp2s,psis_fp2s,Vg0_fp2s,ua,ub,lfp2,Vds_fp2s,gamma0fp2,gamma1fp2,   mulf_tdev,Vdeff,psid_fp2s)
                        psim_fp2s = 0.5*(psis_fp2s + psid_fp2s);
                        psisd_fp2s = psid_fp2s - psis_fp2s;
                        `QGI(Vg0_fp2s,psis_fp2s,psid_fp2s,psim_fp2s,Cg_fp2s,lfp2,qm0fp2,bdosfp2,adosfp2,dfp2,Vtv,w,nf,   Cg_qme,qg_fp2s)
                        `QDI(Vg0_fp2s,psim_fp2s,psis_fp2s,psid_fp2s,psisd_fp2s,lfp2,Vtv,w,nf,Cg_qme,   qd_fp2s)
                        qs_fp2s = -1.0*qg_fp2s -1.0*qd_fp2s;
                    end else begin
                        qg_fp2s = 0;
                        qd_fp2s = 0;
                    end
                end
            `endif
////////// FP3 Current Model //////////
            `ifdef __FP3MOD__
                if (fastfpmod == 0) begin
                    if (fp3mod != 0) begin
                        Vds_noswapfp3 = V(fp3,`IntrinsicDrain_fp2);
                        if (fp3mod == 1) begin
                            Vgs_noswapfp3 = V(gi,`IntrinsicDrain_fp2);
                            Vgd_noswapfp3 = V(gi,fp3);
                        end else begin
                            Vgs_noswapfp3 = V(s,`IntrinsicDrain_fp2);
                            Vgd_noswapfp3 = V(s,fp3);
                        end
                        sigvdsfp3 = 1.0;
                        if (Vds_noswapfp3 < 0.0) begin
                            sigvdsfp3 = -1.0;
                            Vds_fp3 = sigvdsfp3*Vds_noswapfp3 ;
                            Vgs_fp3 = Vgd_noswapfp3 ;
                        end else begin
                            Vds_fp3 = Vds_noswapfp3 ;
                            Vgs_fp3 = Vgs_noswapfp3 ;
                        end

                        Vdsx_fp3 = sqrt(Vds_fp3*Vds_fp3 + 0.01) - 0.1;
                        cdsc = 1.0 + nfactorfp3 + cdscdfp3*Vdsx_fp3; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp3 - (Tdev/Tnom - 1.0)*ktfp3 - (eta0fp3)*(Vdsx_fp3*vdscalefp3)/sqrt(Vdsx_fp3*Vdsx_fp3 + vdscalefp3*vdscalefp3);
                        Cg_fp3 = epsilon/(dfp3);
                        `VG0(lfp3,w,Voff_dibl_temp,iminfp3,Vgs_fp3,Vtv,Vg0_fp3)
                        `PSIS(Cg_fp3,Vg0_fp3,gamma0fp3,gamma1fp3,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp3)
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp3,ute,vsatfp3,at,Cg_fp3,psis_fp3,Vg0_fp3,ua,ub,lfp3,Vds_fp3,gamma0fp3,gamma1fp3,    mulf_tdev,Vdeff,psid_fp3)
                        psim_fp3 = 0.5*(psis_fp3 + psid_fp3);
                        psisd_fp3 = psid_fp3 - psis_fp3 ;
                        `IDS(Vg0_fp3,psim_fp3,psisd_fp3,Cg_fp3,lfp3,Vdsx_fp3,w,nf,Vtv,mulf_tdev,Vdeff,   Ids_fp3)
                        I(fp3,`IntrinsicDrain_fp2) <+ sigvdsfp3*Ids_fp3 + gdsmin*V(fp3,`IntrinsicDrain_fp2);
                        `QGI(Vg0_fp3,psis_fp3,psid_fp3,psim_fp3,Cg_fp3,lfp3,qm0fp3,bdosfp3,adosfp3,dfp3,Vtv,w,nf,   Cg_qme,qg_fp3)
                        `QDI(Vg0_fp3,psim_fp3,psis_fp3,psid_fp3,psisd_fp3,lfp3,Vtv,w,nf,Cg_qme,   qd_fp3)
                        qs_fp3 = -1.0*qg_fp3 -1.0*qd_fp3;
                        if (sigvdsfp3 < 0.0) begin
                            t1 = qs_fp3;
                            qs_fp3 = qd_fp3;
                            qd_fp3 = t1;
                        end
                    end else begin
                        V(fp3,`IntrinsicDrain_fp2) <+ 0.0;
                        qg_fp3 = 0;
                        qd_fp3 = 0;
                    end
                end else begin
                    if (fp3mod != 0) begin
                        if (fp3mod == 1) begin
                            Vgs_noswapfp3 = V(gi,di);
                        end else begin
                            Vgs_noswapfp3 = V(s,di);
                        end
                        sigvdsfp3 = 1.0;
                        Vgs_fp3 = Vgs_noswapfp3;
                        cdsc = 1.0 + nfactorfp3 ; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp3 - (Tdev/Tnom - 1.0)*ktfp3 ;
                        Cg_fp3 = epsilon/(dfp3);
                        `VG0(lfp3,w,Voff_dibl_temp,iminfp3,Vgs_fp3,Vtv,Vg0_fp3)
                        `PSIS(Cg_fp3,Vg0_fp3,gamma0fp3,gamma1fp3,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp3)
                        Vds_fp3 = 0.0;
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp3,ute,vsatfp3,at,Cg_fp3,psis_fp3,Vg0_fp3,ua,ub,lfp3,Vds_fp3,gamma0fp3,gamma1fp3,    mulf_tdev,Vdeff,psid_fp3)
                        psim_fp3 = 0.5*(psis_fp3 + psid_fp3);
                        psisd_fp3 = psid_fp3 - psis_fp3 ;
                        `QGI(Vg0_fp3,psis_fp3,psid_fp3,psim_fp3,Cg_fp3,lfp3,qm0fp3,bdosfp3,adosfp3,dfp3,Vtv,w,nf,   Cg_qme,qg_fp3)
                        `QDI(Vg0_fp3,psim_fp3,psis_fp3,psid_fp3,psisd_fp3,lfp3,Vtv,w,nf,Cg_qme,   qd_fp3)
                        qs_fp3 = -1.0*qg_fp3 -1.0*qd_fp3;
                    end else begin
                        qg_fp3 = 0;
                        qd_fp3 = 0;
                    end
                end
            `endif
//////////// FP3 Source side current model //////////////////////////////////////////////
            `ifdef __FP3SMOD__
                if (fastfpmod == 0) begin
                    if (fp3smod != 0) begin
                        Vds_noswapfp3s = V(`IntrinsicSource_fp2s,fp3s);
                        if (fp3smod == 1) begin
                            Vgs_noswapfp3s = V(gi,fp3s);
                            Vgd_noswapfp3s = V(gi,`IntrinsicSource_fp2s);
                        end else begin
                            Vgs_noswapfp3s = V(s,fp3s);
                            Vgd_noswapfp3s = V(s,`IntrinsicSource_fp2s);
                        end
                        sigvdsfp3s = 1.0;
                        if (Vds_noswapfp3s < 0.0) begin
                            sigvdsfp3s = -1.0;
                            Vds_fp3s = sigvdsfp3s*Vds_noswapfp3s ;
                            Vgs_fp3s = Vgd_noswapfp3s ;
                        end else begin
                            Vds_fp3s = Vds_noswapfp3s ;
                            Vgs_fp3s = Vgs_noswapfp3s ;
                        end

                        Vdsx_fp3s = sqrt(Vds_fp3s*Vds_fp3s + 0.01) - 0.1;
                        cdsc = 1.0 + nfactorfp3 + cdscdfp3*Vdsx_fp3s; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp3 + (Tdev/Tnom - 1.0)*ktfp3 - (eta0fp3)*(Vdsx_fp3s*vdscalefp3)/sqrt(Vdsx_fp3s*Vdsx_fp3s + vdscalefp3*vdscalefp3);
                        Cg_fp3s = epsilon/dfp3;
                        `VG0(lfp3,w,Voff_dibl_temp,iminfp3,Vgs_fp3s,Vtv,Vg0_fp3s)
                        `PSIS(Cg_fp3s,Vg0_fp3s,gamma0fp3,gamma1fp3,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp3s)
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp3,ute,vsatfp3,at,Cg_fp3s,psis_fp3s,Vg0_fp3s,ua,ub,lfp3,Vds_fp3s,gamma0fp3,gamma1fp3,   mulf_tdev,Vdeff,psid_fp3s)
                        psim_fp3s = 0.5*(psis_fp3s + psid_fp3s);
                        psisd_fp3s = psid_fp3s - psis_fp3s;
                        `IDS(Vg0_fp3s,psim_fp3s,psisd_fp3s,Cg_fp3s,lfp3,Vdsx_fp3s,w,nf,Vtv,mulf_tdev,Vdeff,   Ids_fp3s)
                        I(`IntrinsicSource_fp2s,fp3s) <+ sigvdsfp3s*Ids_fp3s + gdsmin*V(`IntrinsicSource_fp2s,fp3s);
                        `QGI(Vg0_fp3s,psis_fp3s,psid_fp3s,psim_fp3s,Cg_fp3s,lfp3,qm0fp3,bdosfp3,adosfp3,dfp3,Vtv,w,nf,   Cg_qme,qg_fp3s)
                        `QDI(Vg0_fp3s,psim_fp3s,psis_fp3s,psid_fp3s,psisd_fp3s,lfp3,Vtv,w,nf,Cg_qme,   qd_fp3s)
                        qs_fp3s = -1.0*qg_fp3s -1.0*qd_fp3s;
                        if (sigvdsfp3s < 0.0) begin
                            t1 = qs_fp3s;
                            qs_fp3s = qd_fp3s;
                            qd_fp3s = t1;
                        end
                    end else begin
                        V(`IntrinsicSource_fp2s,fp3s) <+ 0.0;
                        qg_fp3s = 0;
                        qd_fp3s = 0;
                    end
                end else begin
                    if (fp3smod != 0) begin
                        if (fp3smod == 1) begin
                            Vgs_noswapfp3s = V(gi,si);
                        end else begin
                            Vgs_noswapfp3s = V(s,si);
                        end
                        sigvdsfp3s = 1.0;
                        Vgs_fp3s = Vgs_noswapfp3s;
                        cdsc = 1.0 + nfactorfp3 ; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp3 + (Tdev/Tnom - 1.0)*ktfp3 ;
                        Cg_fp3s = epsilon/dfp3;
                        `VG0(lfp3,w,Voff_dibl_temp,iminfp3,Vgs_fp3s,Vtv,Vg0_fp3s)
                        `PSIS(Cg_fp3s,Vg0_fp3s,gamma0fp3,gamma1fp3,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp3s)
                        Vds_fp3s = 0.0;
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp3,ute,vsatfp3,at,Cg_fp3s,psis_fp3s,Vg0_fp3s,ua,ub,lfp3,Vds_fp3s,gamma0fp3,gamma1fp3,   mulf_tdev,Vdeff,psid_fp3s)
                        psim_fp3s = 0.5*(psis_fp3s + psid_fp3s);
                        psisd_fp3s = psid_fp3s - psis_fp3s;
                        `QGI(Vg0_fp3s,psis_fp3s,psid_fp3s,psim_fp3s,Cg_fp3s,lfp3,qm0fp3,bdosfp3,adosfp3,dfp3,Vtv,w,nf,   Cg_qme,qg_fp3s)
                        `QDI(Vg0_fp3s,psim_fp3s,psis_fp3s,psid_fp3s,psisd_fp3s,lfp3,Vtv,w,nf,Cg_qme,   qd_fp3s)
                        qs_fp3s = -1.0*qg_fp3s -1.0*qd_fp3s;
                    end else begin
                        qg_fp3s = 0;
                        qd_fp3s = 0;
                    end
                end
            `endif
////////// FP4 Current Model //////////
            `ifdef __FP4MOD__
                if (fastfpmod == 0) begin
                    if (fp4mod != 0) begin
                        Vds_noswapfp4 = V(fp4,`IntrinsicDrain_fp3);
                        if (fp4mod == 1) begin
                            Vgs_noswapfp4 = V(gi,`IntrinsicDrain_fp3);
                            Vgd_noswapfp4 = V(gi,fp4);
                        end else begin
                            Vgs_noswapfp4 = V(s,`IntrinsicDrain_fp3);
                            Vgd_noswapfp4 = V(s,fp4);
                        end
                        sigvdsfp4 = 1.0;
                        if (Vds_noswapfp4 < 0.0) begin
                            sigvdsfp4 = -1.0;
                            Vds_fp4 = sigvdsfp4*Vds_noswapfp4 ;
                            Vgs_fp4 = Vgd_noswapfp4 ;
                        end else begin
                            Vds_fp4 = Vds_noswapfp4 ;
                            Vgs_fp4 = Vgs_noswapfp4 ;
                        end

                        Vdsx_fp4 = sqrt(Vds_fp4*Vds_fp4 + 0.01) - 0.1;
                        cdsc = 1.0 + nfactorfp4 + cdscdfp4*Vdsx_fp4; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp4 - (Tdev/Tnom - 1.0)*ktfp4 - (eta0fp4)*(Vdsx_fp4*vdscalefp4)/sqrt(Vdsx_fp4*Vdsx_fp4 + vdscalefp4*vdscalefp4);
                        Cg_fp4 = epsilon/(dfp4);
                        `VG0(lfp4,w,Voff_dibl_temp,iminfp4,Vgs_fp4,Vtv,Vg0_fp4)
                        `PSIS(Cg_fp4,Vg0_fp4,gamma0fp4,gamma1fp4,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp4)
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp4,ute,vsatfp4,at,Cg_fp4,psis_fp4,Vg0_fp4,ua,ub,lfp4,Vds_fp4,gamma0fp4,gamma1fp4,   mulf_tdev,Vdeff,psid_fp4)
                        psim_fp4 = 0.5*(psis_fp4 + psid_fp4);
                        psisd_fp4 = psid_fp4 - psis_fp4;
                        `IDS(Vg0_fp4,psim_fp4,psisd_fp4,Cg_fp4,lfp4,Vdsx_fp4,w,nf,Vtv,mulf_tdev,Vdeff,  Ids_fp4)
                        I(fp4,`IntrinsicDrain_fp3) <+ sigvdsfp4*Ids_fp4 + gdsmin*V(fp4,`IntrinsicDrain_fp3);
                        `QGI(Vg0_fp4,psis_fp4,psid_fp4,psim_fp4,Cg_fp4,lfp4,qm0fp4,bdosfp4,adosfp4,dfp4,Vtv,w,nf,   Cg_qme,qg_fp4)
                        `QDI(Vg0_fp4,psim_fp4,psis_fp4,psid_fp4,psisd_fp4,lfp4,Vtv,w,nf,Cg_qme,   qd_fp4)
                        qs_fp4 = -1.0*qg_fp4 -1.0*qd_fp4;
                        if (sigvdsfp4 < 0.0) begin
                            t1 = qs_fp4;
                            qs_fp4 = qd_fp4;
                            qd_fp4 = t1;
                        end
                    end else begin
                        V(fp4,`IntrinsicDrain_fp3) <+ 0.0;
                        qg_fp4 = 0;
                        qd_fp4 = 0;
                    end
                end else begin
                    if (fp4mod != 0) begin
                        if (fp4mod == 1) begin
                            Vgs_noswapfp4 = V(gi,di);
                        end else begin
                            Vgs_noswapfp4 = V(s,si);
                        end
                        sigvdsfp4 = 1.0;
                        Vgs_fp4 = Vgs_noswapfp4;
                        cdsc = 1.0 + nfactorfp4 ; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp4 - (Tdev/Tnom - 1.0)*ktfp4 ;
                        Cg_fp4 = epsilon/(dfp4);
                        `VG0(lfp4,w,Voff_dibl_temp,iminfp4,Vgs_fp4,Vtv,Vg0_fp4)
                        `PSIS(Cg_fp4,Vg0_fp4,gamma0fp4,gamma1fp4,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp4)
                        Vds_fp4 = 0.0;
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp4,ute,vsatfp4,at,Cg_fp4,psis_fp4,Vg0_fp4,ua,ub,lfp4,Vds_fp4,gamma0fp4,gamma1fp4,   mulf_tdev,Vdeff,psid_fp4)
                        psim_fp4 = 0.5*(psis_fp4 + psid_fp4);
                        psisd_fp4 = psid_fp4 - psis_fp4;
                        `QGI(Vg0_fp4,psis_fp4,psid_fp4,psim_fp4,Cg_fp4,lfp4,qm0fp4,bdosfp4,adosfp4,dfp4,Vtv,w,nf,   Cg_qme,qg_fp4)
                        `QDI(Vg0_fp4,psim_fp4,psis_fp4,psid_fp4,psisd_fp4,lfp4,Vtv,w,nf,Cg_qme,   qd_fp4)
                        qs_fp4 = -1.0*qg_fp4 -1.0*qd_fp4;
                    end else begin
                        qg_fp4 = 0;
                        qd_fp4 = 0;
                    end
                end
            `endif
//////////// FP4 Source side current model //////////////////////////////////////////////
            `ifdef __FP4SMOD__
                if (fastfpmod == 0) begin
                    if (fp4smod != 0) begin
                        Vds_noswapfp4s = V(`IntrinsicSource_fp3s,fp4s);
                        if (fp4smod == 1) begin
                            Vgs_noswapfp4s = V(gi,fp4s);
                            Vgd_noswapfp4s = V(gi,`IntrinsicSource_fp3s);
                        end else begin
                            Vgs_noswapfp4s = V(s,fp4s);
                            Vgd_noswapfp4s = V(s,`IntrinsicSource_fp3s);
                        end
                        sigvdsfp4s = 1.0;
                        if (Vds_noswapfp4s < 0.0) begin
                            sigvdsfp4s = -1.0;
                            Vds_fp4s = sigvdsfp4s*Vds_noswapfp4s ;
                            Vgs_fp4s = Vgd_noswapfp4s ;
                        end else begin
                            Vds_fp4s = Vds_noswapfp4s ;
                            Vgs_fp4s = Vgs_noswapfp4s ;
                        end
                        Vdsx_fp4s = sqrt(Vds_fp4s*Vds_fp4s + 0.01) - 0.1;
                        cdsc = 1.0 + nfactorfp4 + cdscdfp4*Vdsx_fp4s; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp4 + (Tdev/Tnom - 1.0)*ktfp4 - (eta0fp4)*(Vdsx_fp4s*vdscalefp4)/sqrt(Vdsx_fp4s*Vdsx_fp4s + vdscalefp4*vdscalefp4);
                        Cg_fp4s = epsilon/dfp4;
                        `VG0(lfp4,w,Voff_dibl_temp,iminfp4,Vgs_fp4s,Vtv,Vg0_fp4s)
                        `PSIS(Cg_fp4s,Vg0_fp4s,gamma0fp4,gamma1fp4,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp4s)
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp4,ute,vsatfp4,at,Cg_fp4s,psis_fp4s,Vg0_fp4s,ua,ub,lfp4,Vds_fp4s,gamma0fp4,gamma1fp4,   mulf_tdev,Vdeff,psid_fp4s)
                        psim_fp4s = 0.5*(psis_fp4s + psid_fp4s);
                        psisd_fp4s = psid_fp4s - psis_fp4s;
                        `IDS(Vg0_fp4s,psim_fp4s,psisd_fp4s,Cg_fp4s,lfp4,Vdsx_fp4s,w,nf,Vtv,mulf_tdev,Vdeff,   Ids_fp4s)
                        I(`IntrinsicSource_fp3s,fp4s) <+ sigvdsfp4s*Ids_fp4s + gdsmin*V(`IntrinsicSource_fp3s,fp4s);
                        `QGI(Vg0_fp4s,psis_fp4s,psid_fp4s,psim_fp4s,Cg_fp4s,lfp4,qm0fp4,bdosfp4,adosfp4,dfp4,Vtv,w,nf,   Cg_qme,qg_fp4s)
                        `QDI(Vg0_fp4s,psim_fp4s,psis_fp4s,psid_fp4s,psisd_fp4s,lfp4,Vtv,w,nf,Cg_qme,   qd_fp4s)
                        qs_fp4s = -1.0*qg_fp4s -1.0*qd_fp4s;
                        if (sigvdsfp4s < 0.0) begin
                            t1 = qs_fp4s;
                            qs_fp4s = qd_fp4s;
                            qd_fp4s = t1;
                        end
                    end else begin
                        V(`IntrinsicSource_fp3s,fp4s) <+ 0.0;
                        qg_fp4s = 0;
                        qd_fp4s = 0;
                    end
                end else begin
                    if (fp4smod != 0) begin
                        if (fp4smod == 1) begin
                            Vgs_noswapfp4s = V(gi,si);
                        end else begin
                            Vgs_noswapfp4s = V(s,si);
                        end
                        sigvdsfp4s = 1.0;
                        Vgs_fp4s = Vgs_noswapfp4s;
                        cdsc = 1.0 + nfactorfp4; //Sub-threshold Slope
                        Vtv = `KboQ*Tdev*cdsc;
                        Voff_dibl_temp = vofffp4 + (Tdev/Tnom - 1.0)*ktfp4 ;
                        Cg_fp4s = epsilon/dfp4;
                        `VG0(lfp4,w,Voff_dibl_temp,iminfp4,Vgs_fp4s,Vtv,Vg0_fp4s)
                        `PSIS(Cg_fp4s,Vg0_fp4s,gamma0fp4,gamma1fp4,Vtv,   beta,ALPHAN,ALPHAD,Cch,psis_fp4s)
                        Vds_fp4s = 0.0;
                        `PSID(Tdev,Tnom,epsilon,delta,beta,ALPHAN,ALPHAD,Vtv,Cch,u0fp4,ute,vsatfp4,at,Cg_fp4s,psis_fp4s,Vg0_fp4s,ua,ub,lfp4,Vds_fp4s,gamma0fp4,gamma1fp4,   mulf_tdev,Vdeff,psid_fp4s)
                        psim_fp4s = 0.5*(psis_fp4s + psid_fp4s);
                        psisd_fp4s = psid_fp4s - psis_fp4s;
                        `QGI(Vg0_fp4s,psis_fp4s,psid_fp4s,psim_fp4s,Cg_fp4s,lfp4,qm0fp4,bdosfp4,adosfp4,dfp4,Vtv,w,nf,   Cg_qme,qg_fp4s)
                        `QDI(Vg0_fp4s,psim_fp4s,psis_fp4s,psid_fp4s,psisd_fp4s,lfp4,Vtv,w,nf,Cg_qme,   qd_fp4s)
                        qs_fp4s = -1.0*qg_fp4s -1.0*qd_fp4s;
                    end else begin
                        qg_fp4s = 0;
                        qd_fp4s = 0;
                    end
                end
            `endif
////////// Gate Resistance //////////
            if (rgatemod == 1) begin
                Grgeltd = rshg * (xgw + w / 3.0 / ngcon)/ ( ngcon * nf * (l));
                if (Grgeltd > 0.0) begin
                    Grgeltd = 1.0 / Grgeltd;
                end else begin
                    Grgeltd = 1.0/$simparam("minr",1.0e-3);
                end
                I(g,gi) <+ Grgeltd * V(g,gi);
                V(gin,gi) <+ 0.0;
            end else if (rgatemod == 2) begin
                Grgeltd1 = rshg * (xgw + w / 3.0 / ngcon)/ ( ngcon * nf * (l));
                Grgeltd2 = rshg * (2.0 * w / 3.0 / ngcon)/ ( ngcon * nf * (l));
                if (Grgeltd1 > 0.0) begin
                    Grgeltd1 = 1.0 / Grgeltd1;
                end else begin
                    Grgeltd1 = 1.0/$simparam("minr",1.0e-3);
                end
                I(g,gin) <+ Grgeltd1 * V(g,gin);
                if (Grgeltd2 > 0.0) begin
                    Grgeltd2 = 1.0 / Grgeltd2;
                end else begin
                    Grgeltd2 = 1.0/$simparam("minr",1.0e-3);
                end
                I(gin,gi) <+ Grgeltd2 * V(gin,gi);
            end else begin
                V(g, gin) <+ 0.0;
                V(gin, gi) <+ 0.0;
            end
////////// Parasitic Charges //////////
            if (rgatemod == 2) begin
                qsov = w*nf*cgso*V(gin,s);
                VdseffCV = V(d,s)*vdsatcv/sqrt(V(d,s)*V(d,s) + vdsatcv*vdsatcv);
                cgdl_l = min(cgdl,cgdo/(2*vdsatcv));
                cgdvar  = w*nf*cgdo - w*nf*cgdl_l*VdseffCV;
                qdov = max(cgdvar,0.0)*V(gin,d);
            end else begin
                qsov = w*nf*cgso*V(g,s);
                VdseffCV = V(d,s)*vdsatcv/sqrt(V(d,s)*V(d,s) + vdsatcv*vdsatcv);
                cgdl_l = min(cgdl,cgdo/(2*vdsatcv));
                cgdvar  = w*nf*cgdo - w*nf*cgdl_l*VdseffCV;
                qdov = max(cgdvar,0.0)*V(g,d);
            end
            qdsov = w*nf*cdso*V(d,s);
            qdp = - qdov + qdsov;
            qsp = - qsov - qdsov;
            qd = qdint + qdp;
            qs = qsint + qsp;
            qbdov = w*nf*cbdo*V(b,d);
            qbsov = w*nf*cbso*V(b,s);
            qbgov = w*nf*cbgo*V(b,g);

////////// Flicker Noise Model //////////
            if (fnmod==1) begin
                Kr  =  l/((Vg0-psim+Vtv)*max(psisd,1.0e-12));
                Pf  =  Vtv*`P_Q*`P_Q*`P_Q/(w*nf*l*l);
                FNint1  = noia*Vtv*Cg*(1.0/(max(qd,1.0e-22)))*(1.0-(qd/(max(qs,1.0e-22))));
                FNint2  = (noia+noib*Vtv*Cg)*ln(max(qd,1.0e-22)/max(qs,1.0e-22));
                FNint3  = (noib+noic*Vtv*Cg)*(qs-qd);
                FNint4  = (noic/2.0)*(qd*qd-qs*qs);
                FNat1Hz = Pf*(Ids*Ids)*(Kr/(Cg*Cg))*(FNint1+FNint2+FNint3+FNint4); //PSD of the flicker noise without the frequency component
                if (sigvds < 0) begin
                    FNat1Hz = -FNat1Hz;
                end
                I(di,si) <+ flicker_noise(FNat1Hz, ef, "flicker");
            end
////////// Capacitance Contributions //////////
            I(di,si) <+ ddt(qdint);
            I(gi,si) <+ ddt(qgint);
            if (rgatemod == 2) begin
                I(gin,s) <+ ddt(qsov);
                I(gin,d) <+ ddt(qdov);
            end else begin
                I(g,s) <+ ddt(qsov);
                I(g,d) <+ ddt(qdov);
            end
            I(d,s) <+ ddt(qdsov);
            I(b,d) <+ ddt (qbdov);
            I(b,s) <+ ddt (qbsov);
            I(b,g) <+ ddt (qbgov);
            I(b,si) <+ ddt(csubscalei*qgint);
            `ifdef __FP1MOD__
                if (fastfpmod == 0) begin
                    if (fp1mod!=0) begin
                        I(fp1,di) <+ddt(qd_fp1);
                        if (fp1mod == 1) begin
                            I(gi, di) <+ ddt(qg_fp1) ;
                            I(s,di) <+ ddt(qg_fp1)*cfp1scale ;
                        end else begin
                            I(s,di) <+ ddt(qg_fp1) ;
                            I(gi, di) <+ ddt(qg_fp1)*cfp1scale ;
                        end
                        I(b,di) <+ ddt(csubscale1*qg_fp1);
                    end
                end else begin
                    if (fp1mod!=0) begin
                        I(d,di) <+ddt(qd_fp1);
                        if (fp1mod == 1) begin
                            I(gi, di) <+ ddt(qg_fp1) ;
                            I(s,di) <+ ddt(qg_fp1)*cfp1scale ;
                        end else begin
                            I(s,di) <+ ddt(qg_fp1) ;
                            I(gi, di) <+ ddt(qg_fp1)*cfp1scale ;
                        end
                        I(b,di) <+ ddt(csubscale1*qg_fp1);
                    end
                end
            `endif
            `ifdef __FP1SMOD__
                if (fastfpmod == 0) begin
                    if (fp1smod!=0) begin
                        I(si,fp1s) <+ddt(qd_fp1s);
                        if (fp1smod == 1) begin
                            I(gi, fp1s) <+ ddt(qg_fp1s) ;
                            I(s,fp1s) <+ ddt(qg_fp1s)*cfp1scale ;
                        end else begin
                            I(s,fp1s) <+ ddt(qg_fp1s) ;
                            I(gi,fp1s) <+ ddt(qg_fp1s)*cfp1scale ;
                        end
                        I(b,fp1s) <+ ddt(csubscale1*qg_fp1s);
                    end
                end else begin
                    if (fp1smod!=0) begin
                        I(si,s) <+ddt(qd_fp1s);
                        if (fp1smod == 1) begin
                            I(gi, si) <+ ddt(qg_fp1s) ;
                            I(s,si) <+ ddt(qg_fp1s)*cfp1scale ;
                        end else begin
                            I(s,si) <+ ddt(qg_fp1s) ;
                            I(gi,si) <+ ddt(qg_fp1s)*cfp1scale ;
                        end
                        I(b,si) <+ ddt(csubscale1*qg_fp1s);
                    end
                end
            `endif
            `ifdef __FP2MOD__
                if (fastfpmod == 0) begin
                    if (fp2mod!=0) begin
                        I(fp2, `IntrinsicDrain_fp1) <+ddt(qd_fp2);
                        if (fp2mod == 1) begin
                            I(gi,`IntrinsicDrain_fp1)<+ ddt(qg_fp2);
                            I(s,`IntrinsicDrain_fp1)<+ cfp2scale*ddt(qg_fp2) ;
                        end else begin
                            I(s,`IntrinsicDrain_fp1)<+ ddt(qg_fp2);
                            I(gi,`IntrinsicDrain_fp1) <+  cfp2scale*ddt(qg_fp2) ;
                        end
                        I(b,fp1) <+ ddt(csubscale2*qg_fp2);
                    end
                end else begin
                    if (fp2mod!=0) begin
                        I(d, di) <+ddt(qd_fp2);
                        if (fp2mod == 1) begin
                            I(gi,di)<+ ddt(qg_fp2);
                            I(s,di)<+ cfp2scale*ddt(qg_fp2) ;
                        end else begin
                            I(s,di)<+ ddt(qg_fp2);
                            I(gi,di) <+  cfp2scale*ddt(qg_fp2) ;
                        end
                        I(b,di) <+ ddt(csubscale2*qg_fp2);
                    end
                end
            `endif
            `ifdef __FP2SMOD__
                if (fastfpmod == 0) begin
                    if (fp2smod!=0) begin
                        I(si,fp2s) <+ddt(qd_fp2s);
                        if (fp2smod == 1) begin
                            I(gi, fp2s) <+ ddt(qg_fp2s) ;
                            I(s,fp2s) <+ ddt(qg_fp2s)*cfp2scale ;
                        end else begin
                            I(s,fp2s) <+ ddt(qg_fp2s) ;
                            I(gi,fp2s) <+ ddt(qg_fp2s)*cfp2scale ;
                        end
                        I(b,fp2s) <+ ddt(csubscale2*qg_fp2s);
                    end
                end else begin
                    if (fp2smod!=0) begin
                        I(si,s) <+ddt(qd_fp2s);
                        if (fp2smod == 1) begin
                            I(gi, si) <+ ddt(qg_fp2s) ;
                            I(s,si) <+ ddt(qg_fp2s)*cfp2scale ;
                        end else begin
                            I(s,si) <+ ddt(qg_fp2s) ;
                            I(gi,si) <+ ddt(qg_fp2s)*cfp2scale ;
                        end
                        I(b,si) <+ ddt(csubscale2*qg_fp2s);
                    end
                end
            `endif
            `ifdef __FP3MOD__
                if (fastfpmod == 0) begin
                    if (fp3mod!=0) begin
                        I(fp3, `IntrinsicDrain_fp2) <+ddt(qd_fp3);
                        if (fp3mod == 1) begin
                            I(gi,`IntrinsicDrain_fp2)<+ ddt(qg_fp3);
                            I(s,`IntrinsicDrain_fp2)<+ ddt(qg_fp3)*cfp3scale;
                        end else begin
                            I(s,`IntrinsicDrain_fp2)<+ ddt(qg_fp3);
                            I(gi,`IntrinsicDrain_fp2)<+ ddt(qg_fp3)*cfp3scale;
                        end
                        I(b,fp2) <+ ddt(csubscale3*qg_fp3);
                    end
                end else begin
                    if (fp3mod!=0) begin
                        I(d, di) <+ddt(qd_fp3);
                        if (fp3mod == 1) begin
                            I(gi,di)<+ ddt(qg_fp3);
                            I(s,di)<+ ddt(qg_fp3)*cfp3scale;
                        end else begin
                            I(s,di)<+ ddt(qg_fp3);
                            I(gi,di)<+ ddt(qg_fp3)*cfp3scale;
                        end
                        I(b,di) <+ ddt(csubscale3*qg_fp3);
                    end
                end
            `endif
            `ifdef __FP3SMOD__
                if (fastfpmod == 0) begin
                    if (fp3smod!=0) begin
                        I(si,fp3s) <+ddt(qd_fp3s);
                        if (fp3smod == 1) begin
                            I(gi, fp3s) <+ ddt(qg_fp3s) ;
                            I(s,fp3s) <+ ddt(qg_fp3s)*cfp3scale ;
                        end else begin
                            I(s,fp3s) <+ ddt(qg_fp3s) ;
                            I(gi,fp3s) <+ ddt(qg_fp3s)*cfp3scale ;
                        end
                        I(b,fp3s) <+ ddt(csubscale3*qg_fp3s);
                    end
                end else begin
                    if (fp3smod!=0) begin
                        I(si,s) <+ddt(qd_fp3s);
                        if (fp3smod == 1) begin
                            I(gi, s) <+ ddt(qg_fp3s) ;
                            I(s,si) <+ ddt(qg_fp3s)*cfp3scale ;
                        end else begin
                            I(s,si) <+ ddt(qg_fp3s) ;
                            I(gi,si) <+ ddt(qg_fp2s)*cfp3scale ;
                        end
                        I(b,si) <+ ddt(csubscale3*qg_fp3s);
                    end
                end
            `endif
            `ifdef __FP4MOD__
                if (fastfpmod == 0) begin
                    if (fp4mod!=0) begin
                        I(fp4, `IntrinsicDrain_fp3) <+ddt(qd_fp4);
                        if (fp4mod == 1) begin
                            I(gi,`IntrinsicDrain_fp3)<+ ddt(qg_fp4);
                            I(s,`IntrinsicDrain_fp3)<+ ddt(qg_fp4)*cfp4scale;
                        end else begin
                            I(s,`IntrinsicDrain_fp3)<+ ddt(qg_fp4);
                            I(gi,`IntrinsicDrain_fp3)<+ ddt(qg_fp4)*cfp4scale;
                        end
                        I(b,fp3) <+ ddt(csubscale4*qg_fp4);
                    end
                end else begin
                    if (fp4mod!=0) begin
                        I(d, di) <+ddt(qd_fp4);
                        if (fp4mod == 1) begin
                            I(gi,di)<+ ddt(qg_fp4);
                            I(s,di)<+ ddt(qg_fp4)*cfp4scale;
                        end else begin
                            I(s,di)<+ ddt(qg_fp4);
                            I(gi,di)<+ ddt(qg_fp4)*cfp4scale;
                        end
                        I(b,di) <+ ddt(csubscale4*qg_fp4);
                    end
                end
            `endif
            `ifdef __FP4SMOD__
                if (fastfpmod == 0) begin
                    if (fp4smod!=0) begin
                        I(si,fp4s) <+ddt(qd_fp4s);
                        if (fp4smod == 1) begin
                            I(gi, fp4s) <+ ddt(qg_fp4s) ;
                            I(s,fp4s) <+ ddt(qg_fp4s)*cfp4scale ;
                        end else begin
                            I(s,fp4s) <+ ddt(qg_fp4s) ;
                            I(gi,fp4s) <+ ddt(qg_fp4s)*cfp4scale ;
                        end
                        I(b,fp4s) <+ ddt(csubscale4*qg_fp4s);
                    end
                end else begin
                    if (fp4smod!=0) begin
                        I(si,s) <+ddt(qd_fp4s);
                        if (fp4smod == 1) begin
                            I(gi, s) <+ ddt(qg_fp4s) ;
                            I(s,si) <+ ddt(qg_fp4s)*cfp4scale ;
                        end else begin
                            I(s,si) <+ ddt(qg_fp4s) ;
                            I(gi,si) <+ ddt(qg_fp4s)*cfp4scale ;
                        end
                        I(b,si) <+ ddt(csubscale4*qg_fp4s);
                    end
                end
            `endif
////////// Fringe Capacitance For Additional Tuning //////////
            qfr = cfgd0 - (cfgd + (Tdev/Tnom - 1.0)* ktcfgd) * V(d,s);
            qfr = w*nf*hypmax(qfr,1.0e-25,cfgdsm);
            I(g,d) <+ddt(qfr);
            I(g,s) <+ ddt(w*nf*cfgd*V(g,s));
            t0 = smoothminx(cfg-((Tdev/Tnom - 1.0)*ktcfg), 1.0e-18, 0.1e-18);
            qfr2 = w*nf*t0*V(gi, s);
            I(gi, s) <+ ddt(qfr2);
            qfr3 = w*nf*cfd*V(s,d);
            I(s,d) <+ ddt(qfr3);

////////// Depletion Capacitance Model //////////
            t0 = (vbi - (Tdev/Tnom - 1.0)*ktvbi)*(1.0-lexp(-ln(aj)/mz));
            t1 = (t0-V(s,d))/Vth;
            t2 = sqrt(dj*t1*t1+ 1.92);
            t3 = (t1+t2)*0.5;
            t4 = t0-Vth*t3;
            t5 = t3/t2;
            t6 = ln(1.0-t4/vbi);
            t8 = cj0*(vbi - (Tdev/Tnom - 1.0)*ktvbi)*(1.0-lexp(t6*(1.0-mz)))/(1.0-mz);
            Qdep = w*nf*(t8+aj*cj0*(V(s,d)-t4));
            I(s,d) <+ ddt(Qdep);  //

////////// Self-Heating Effect //////////
            if (shmod == 1 && rth0>0) begin
                Pwr(ith) <+ -1.0*Ids*Vds-1.0*Ids_fp1*Vds_fp1-1.0*Ids_fp2*Vds_fp2-1.0*Ids_fp3*Vds_fp3-1.0*Ids_fp4*Vds_fp4;
                Pwr(rth) <+ Temp(rth)/rth0;
                Pwr(rth) <+ ddt(Temp(rth)*cth0);
            end else begin
                Temp(dt) <+ 0.0 ;
            end
/////////  Output info variables
            idisi = I(di,si);
            vdisi = V(di,si);
            vgisi = V(gi,si);
            gmi   = sigvds * ddx(Ids,V(gi));
            gmbi  = 0.0; // sigvds * ddx(Ids,V(b)) if Vb dependence is added;
            if (sigvds > 0) begin
                gdsi  = ddx(Ids,V(di));
            end else begin
                gdsi  = ddx(Ids,V(si));
            end
            igs   = Igs;
            igd   = Igd;
            qgi   = qgint;
            qdi   = qdint;
            qsi   = qsint;
            qbi   = csubscalei*qgint;
            cggi  = ddx(qgi,V(gi));
            cgsi  = -ddx(qgi,V(si));
            cgdi  = -ddx(qgi,V(di));
            cgbi  = 0.0; // -ddx(qgi,V(b)) if Vb dependence is added;
            cddi  = ddx(qdi,V(di));
            cdgi  = -ddx(qdi,V(gi));
            cdsi  = -ddx(qdi,V(si));
            cdbi  = 0.0; //-ddx(qdi,V(b)) if Vb dependence is added;
            cssi  = ddx(qsi,V(si));
            csgi  = -ddx(qsi,V(gi));
            csdi  = -ddx(qsi,V(di));
            csbi  = 0.0; // -ddx(qsi,V(b)) if Vb dependence is added;
            cbbi  = 0.0; // ddx(qbi,V(b)) if Vb dependence is added;
            cbgi  = -ddx(qbi,V(gi));
            cbdi  = -ddx(qbi,V(di));
            cbsi  = -ddx(qbi,V(si));
            t_total_k  = Tdev;
            t_total_c  = Tdev - `P_CELSIUS0;
            t_delta_sh = Temp(dt);
            rd         = Rdrain;
            rs         = Rsource;
            cgs        = cgsi + (-ddx(qsov,V(s)));
            cgd        = cgdi + (-ddx(qdov,V(d)));
        end
    end
endmodule
